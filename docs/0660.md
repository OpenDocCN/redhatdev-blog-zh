# 一种颠倒的 GCC 优化方法

> 原文：<https://developers.redhat.com/blog/2019/10/11/a-upside-down-approach-to-gcc-optimizations>

编译器中的许多传统优化都是采用自顶向下的方法，从程序的开头开始，然后向底层进行。这允许优化在使用某个东西之前看到它的定义，这简化了大多数评估。这也是我们处理事情的自然方式。在本文中，我们将关注一种不同的方法和一个名为 [Ranger](https://gcc.gnu.org/wiki/AndrewMacLeod/ProjectRanger) 的新项目，该项目试图彻底解决这个问题。

让我们首先看看 GCC 中的值域传播(VRP)优化过程。我们处理语句以确定我们可以计算的范围类型，并基于这些结果执行一些优化:

```
func (unsigned b)
{
  unsigned A;
  if (B < 10)
  {
    A = B + 10;
    if (A > 20)
      dead_call ();
  }
}

```

首先，检查语句`if (B < 10)`。在不知道关于 B 的任何其他信息的情况下，我们知道，如果条件为真，B 必须在范围[0..9]对于 then 块中 B 的所有使用。

接下来，我们处理`A = B + 10`语句。我们知道 B 的范围，所以现在很容易确定 A 必须具有 B + 10 的范围，其计算结果为[10..19].

当考虑下一个语句`if (A > 20)`时，我们已经计算出 A 在范围【10..19]因而(A > 20)的比较必然总是假的。这允许 pass 删除对`dead_call()`的调用，知道它永远不会被调用。

## 当自上而下的方法失败时

这种自上而下的方法的一个问题是遇到事情的顺序会影响结果。例如，假设我们的代码片段被重新排列:

```
A = B + 10;
if (B < 10)
{
  if (A > 20)
    dead_call ();
}

```

这个程序在功能上是相同的；但是，使用自上而下的方法，我们现在看到了前面的`A = B + 10`语句，这是在我们知道关于 b 的值域的任何有用信息之前。这意味着我们在这个赋值中几乎没有学到关于 A 的值域的有用信息。

接下来，我们知道 then 块中 B 测试范围是[0..9]，跟上次一样。

当我们最终看到表达式`if (A > 20)`时，我们对 A 的范围了解得还不够，不能确定消除对`dead_call()`的调用是安全的。在程序的早期移动赋值语句导致我们错过了这个优化。

这就是为什么优化有时能优化你的代码，而有时却不能；语句的显示顺序会影响结果。

## 其他问题

自上而下方法的另一个问题是，我们必须为我们看到的所有东西计算一个范围，因为我们不知道我们以后是否需要它。在第二个例子中，我们实际上从来不需要 B 的范围，所以计算和携带它是浪费时间。情况往往如此。

总是计算和携带所有可能的信息也是禁止的。为了帮助减轻这一负担，我们开发了“启发式”，这基本上是对什么可能是重要的有根据的猜测。我们只计算我们认为需要的数据，如果我们做对了，一切都好！如果我们猜错了，那么，这是另一个错过的优化。错误报告有时会导致试图修复问题的杂耍试探法，有时会导致另一个错误报告浮出水面，因为现在我们遗漏了一些东西！

## 重新表述问题

在过去的 3 年里，我们在 Red Hat 开发了一个名为 Ranger 的新编译器项目。对于 VRP 来说，这是一个颠倒这个问题的尝试，我们不是使用试探法或总是计算范围，而是按需做*。在这种方法中，我们推迟任何计算，直到我们实际上需要一个范围，并教会编译器如何通过返回给表达式的语句来得出答案。这样，我们只做获得我们需要的值所需的工作，而不做额外的工作。*

让我们再来看看我们的第一个例子:

```
if (B < 10)
{
  A = B + 10;
  if (A > 20)
    dead_call ();
}

```

我们知道，如果 B 的范围小于 10，则第一个条件`if (B < 10)`可以被删除，因此查询 B 的范围是什么。我们不能确定关于 B 的任何事情，所以我们对它什么也不做。

最终，我们看着`if (A > 20)`，并且:

*   查询 a 的范围。
*   然后，Ranger 查看 A 的定义，看到它被定义为`B + 10`。
*   它继续查询 B 在该特定点的范围。
*   Ranger 然后回头看，发现这个代码是由`if (B < 10)`控制的。
*   这意味着我们知道 B 的范围是[0..9].
*   我们回到 A 的定义，和第一个例子一样，确定 A 的值域为[10..19].
*   最后，我们返回到`if (A > 20)`，报告范围【10..19]并再次确定呼叫可以被删除。

## 消除订购问题

Ranger 的一个优势是，我们如何得出`if (A > 20)`声明并不重要。Ranger 仍然会给出相同的答案，因为它会根据遇到的顺序，回顾需要和不需要的指令。

现在，让我们重新看看第二个例子:

```
a = b + 10;
if (b < 10)
{
  if (a > 20)
    dead_call ();
}

```

我们将再次直接跳到`if (A > 20)`语句，并且:

*   问护林员 a 的范围。
*   凭借向后看的能力，它找到了`A = B + 10`。
*   在返回定义语句的过程中，它也看到这个块是由`if (B < 10)`选通的，所以它也知道 B = [0..9]在这条道路上。
*   在程序的这一点上，我们只询问 A 的具体值，因此我们可以使用 B 的这个门控值将 A 评估为“B + 10”。这允许我们将 B 用作[0..9]并有效地*重新评估该块中的* A。
*   我们再次计算出 A 的范围是[10..19].
*   这允许我们删除对`dead_call()`的调用，就像之前一样。

## 转向生产

这个简单的例子显示了我们是如何试图消除自顶向下分析顺序的需要，这有助于消除对启发式的需要，并且应该产生更一致的优化结果。

这个项目的大部分研究都是为了控制随需应变分析的性能，这样它就不会比更简单的自顶向下方法更昂贵。Ranger 只做实际需要的工作，所以我们也看到在不需要很多范围的优化过程中节省了大量时间。我们希望将来将这种方法扩展到其他优化中。

这项工作是在当前的 GCC 开发分支中进行的，现在能够构建一个完整的 Fedora 发行版。我们计划在下一个版本 GCC 11 中将其与主流 GCC 集成。

如果你对更多细节感兴趣，你可以在 [GCC wiki](https://gcc.gnu.org/wiki/AndrewMacLeod/ProjectRanger) 上看到关于 Ranger 项目、其方法和我们的结果的文档。

*Last updated: July 1, 2020*