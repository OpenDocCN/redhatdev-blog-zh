# C 数组大小如何成为库的二进制接口的一部分

> 原文:[https://developers . red hat . com/blog/2019/05/06/how-c-array-size-be-part-of-binary-interface-a-library](https://developers.redhat.com/blog/2019/05/06/how-c-array-sizes-become-part-of-the-binary-interface-of-a-library)

大多数 C 编译器允许访问声明为`extern`的数组，该数组具有不确定的边界，如下所示:

```
extern int external_array[];

int
array_get (long int index)
{
  return external_array[index];
}

```

external_array 的定义可能位于不同的翻译单元中，如下所示:

```
int external_array[3] = { 1, 2, 3 };

```

问题是如果这个单独的定义变成这样会发生什么:

```
int external_array[4] = { 1, 2, 3, 4 };

```

或者这个:

```
int external_array[2] = { 1, 2 };

```

这两种改变都保留了二进制接口吗(假设有一种机制允许应用程序在运行时确定数组的大小)？

奇怪的是，答案是在许多架构上，*增加数组大小*会破坏二进制接口(ABI)的兼容性。减小数组大小也可能导致兼容性问题。在本文中，我们将更仔细地研究 ABI 兼容性，并解释如何避免问题。

# 如何链接可执行文件的数据部分

为了理解数组大小如何成为二进制接口的一部分，我们首先需要检查可执行文件的数据部分是如何链接的。细节当然是特定于体系结构的，这里我们主要关注 x86-64 体系结构。

x86-64 架构支持相对于程序计数器的寻址，这意味着对全局数组变量的访问(如前面所示的`array_get`函数)可以编译成一条`movl`指令:

```
array_get:
	movl	external_array(,%rdi,4), %eax
	ret

```

由此，汇编程序产生一个目标文件，其中的指令用一个`R_X86_64_32S`重定位标记。

```
0000000000000000 :
   0:	mov    0x0(,%rdi,4),%eax
			3: R_X86_64_32S	external_array
   7:	retq   

```

这种重新定位告诉链接编辑器(`ld`)在生成可执行文件时，在链接时填充`external_array`变量的适当位置。

这有两个重要的后果。

*   因为可变偏移量是在链接时确定的，所以确定它没有运行时开销。唯一的代价就是内存访问本身。
*   为了确定偏移量，需要知道所有数据变量的大小。否则，就不可能在链接时计算数据段的布局。

对于以[可执行文件和链接格式(ELF)](http://www.sco.com/developers/gabi/latest/contents.html) 为目标的 C 实现，如在 GNU/Linux 上使用的，对`extern`变量的引用不携带对象大小。对于`array_get`的例子，编译器甚至不知道对象的大小。事实上，整个汇编文件看起来是这样的(只是省略了使用`-fno-asynchronous-unwind-tables`的展开信息，这在技术上是 psABI 兼容所必需的):

```
	.file	"get.c"
	.text
	.p2align 4,,15
	.globl	array_get
	.type	array_get, @function
array_get:
	movl	external_array(,%rdi,4), %eax
	ret
	.size	array_get, .-array_get
	.ident	"GCC: (GNU) 8.3.1 20190223 (Red Hat 8.3.1-2)"
	.section	.note.GNU-stack,"",@progbits

```

在这个汇编文件中根本没有关于`external_array`的大小信息:对符号的唯一引用是在带有`movl`指令的那一行，指令中唯一的数字数据是数组元素的大小(由`movl`和缩放因子 4 暗示)。

如果 ELF 要求未定义变量的符号大小，那么甚至不可能编译`array_get`函数。

链接编辑器如何获取实际的符号大小？它查看符号定义，并使用在那里找到的大小信息。这允许链接编辑器计算数据节布局，并用适当的偏移量填充数据重定位。

# ELF 共享对象简介

ELF 的 c 实现不需要程序员添加源代码标记来指示函数或变量是位于当前对象(可以是库或主可执行文件)还是不同的对象中。链接编辑器和动态加载器应该透明地处理这个问题，不需要程序员的帮助。

同时，对于可执行文件，人们希望不要通过改变可执行文件的编译模型来降低性能。这意味着当编译主程序的源代码时(即，没有`-fPIC`，在这种特殊情况下，也没有`-fPIE`)，在引入动态共享对象之前，`array_get`函数被编译成与*完全相同的*指令序列。此外，`external_array`变量是否在主可执行文件本身中定义，或者是否在运行时单独加载某个共享对象都无关紧要。在这两种情况下，编译器产生的指令是相同的。

这怎么可能？毕竟 ELF 共享对象是位置无关的。它们在运行时被加载到*不可预测的随机地址*。然而编译器生成一个机器码序列，要求这些变量在程序运行之前很久就被放置在链接时间计算的*固定偏移量处。*

答案与只有一个加载的对象(主可执行文件)使用这些固定偏移量的事实有关。所有其他对象(动态加载程序本身、C 运行时库和程序使用的任何其他库)都被编译和链接为完全位置独立(PIC)对象。对于这样的对象，编译器引入了额外的间接寻址，从全局偏移量表(GOT)加载每个变量的实际地址。如果我们用`-fPIC`编译`array_get`示例，我们可以看到这种间接性，从而产生以下汇编代码:

```
array_get:
	movq	external_array@GOTPCREL(%rip), %rax
	movl	(%rax,%rdi,4), %eax
	ret

```

因此，`external_array`变量的地址不再是硬编码的，可以在运行时通过相应地初始化它的 get 条目来改变。这意味着在运行时，`external_array`的定义可以包含在同一个共享对象、不同的共享对象或主程序中。动态加载器将基于 ELF 符号查找规则找到适当的定义，并通过将 get 条目更新到其实际地址，将未定义的符号引用绑定到其定义。

让我们回到最初的例子，这里的`array_get`函数位于主程序中，所以变量地址没有间接性。链接编辑器中实现的关键思想是主程序将提供变量`external_array`的定义*，即使它实际上是在运行时*在一个共享对象中定义的。在运行时，动态加载器不会将所有共享对象指向包含该变量的共享对象中该变量的原始定义，而是会在可执行文件的数据段中选择该变量的一个*副本*。

这有两个重要的后果。首先，回想一下`external_array`的定义是这样的:

```
int external_array[3] = { 1, 2, 3 };

```

这个定义有一个初始化器，这个初始化器必须应用于主可执行文件中的定义。为了方便起见，主可执行文件包含一个符号的*副本重定位*。`readelf -rW`命令将其显示为`R_X86_64_COPY`重定位:

```
Relocation section '.rela.dyn' at offset 0x408 contains 3 entries:
    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend
0000000000403ff0  0000000100000006 R_X86_64_GLOB_DAT      0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0
0000000000403ff8  0000000200000006 R_X86_64_GLOB_DAT      0000000000000000 __gmon_start__ + 0
0000000000404020  0000000300000005 R_X86_64_COPY          0000000000404020 external_array + 0

```

像其他重定位一样，副本重定位由动态加载器处理。它涉及一个简单的逐位复制操作。拷贝的目标由重定位偏移量决定(示例中为`0000000000404020`)。源是在运行时根据符号名(`external_array`)及其分辨率(其值)确定的。在进行复制时，动态加载程序还会查看符号的大小，以获得需要复制的字节数。为了使这一切成为可能，`external_array`符号被自动从可执行文件中导出，作为一个已定义的符号，这样它在运行时对动态加载器是可见的。动态符号表(`.dynsym`)反映了这一点，如`readelf -sW`命令所示:

```
Symbol table '.dynsym' contains 4 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FUNC    GLOBAL DEFAULT  UND __libc_start_main@GLIBC_2.2.5 (2)
     2: 0000000000000000     0 NOTYPE  WEAK   DEFAULT  UND __gmon_start__
     3: 0000000000404020    12 OBJECT  GLOBAL DEFAULT   22 external_array

```

大小信息来自哪里(在这个例子中是 12 个字节)？链接编辑器在链接命令行上打开所有共享对象，搜索定义，并使用在那里找到的大小信息。和以前一样，这允许链接编辑器计算数据部分的布局，因此可以使用固定的偏移量。和以前一样，主可执行文件中定义的大小是固定的，在运行时不能改变。

在主可执行文件中，动态链接器还将共享对象中的符号引用重定向到副本重定位的目标。这确保了整个程序中只存在变量的一个副本，正如 C 语言语义所要求的那样。否则，如果变量在初始化后被修改，那么来自主可执行文件的更新对于动态共享对象将是不可见的，反之亦然。

# 对二进制兼容性的影响

如果我们改变共享对象中`external_array`的定义，而不重新链接(或重新编译)主程序，会发生什么？首先，让我们考虑数组元素的*加法*。

```
int external_array[4] = { 1, 2, 3, 4 };

```

这将在运行时触发来自动态加载器的警告:

```
*main-program*: Symbol `external_array' has different size in shared object, consider re-linking

```

主程序仍然包含了一个`external_array`的定义，只提供了 12 字节的空间。这意味着复制是不完整的:只复制了前三个数组元素。因此，对数组元素`extern_array[3]`的访问是未定义的。这种方法影响进程中的所有代码，而不仅仅是主程序，因为所有对`extern_array`的引用都被重定向到主程序中的定义。这包括共享对象，它提供了`extern_array`的定义，很可能是没有准备好处理自己定义中数组元素没了的情况。

反方向的变化呢，去掉一个元素，像这样？

```
int external_array[2] = { 1, 2, 3 };

```

如果程序避免访问数组元素`extern_array[2]`,因为它通过某种机制检测到数组长度只有 2，那么这将起作用。数组后有一点未使用的内存，但这不会中断程序。

这意味着我们最终得到以下规则:

> 向全局数组变量添加元素会破坏二进制兼容性。
> 删除元素可能会破坏兼容性，除非有一种机制
> 可以避免访问被删除的元素。

不幸的是，动态加载器警告看起来比实际上更无害，对于被删除的元素，根本没有警告。

# 如何避免这种情况

使用诸如 [libabigail](https://sourceware.org/libabigail/) 这样的工具来检测 ABI 变化是相当容易的。

避免这种情况的最简单方法是使用如下代码提供一个返回数组地址的函数:

```
static int local_array[3] = { 1, 2, 3 };

int *
get_external_array (void)
{
  return local_array;
}

```

如果数组定义由于它在库中的使用方式而不能成为静态的，我们可以改为给它隐藏的可见性，也防止它的导出，从而避免截断问题:

```
int local_array[3] __attribute__ ((visibility ("hidden"))) =
  { 1, 2, 3 };

```

如果因为向后兼容的原因需要导出数组变量，事情就复杂多了。因为如果使用具有较短数组定义的旧主程序，数组将在库下被截断，所以如果访问器函数与相同的全局数组一起使用，它将不会为较新的客户端代码提供对完整数组的访问。取而代之的是，访问器函数可以使用一个单独的(静态的或隐藏的)数组，或者在末尾为新添加的元素使用一个单独的数组。缺点是，如果为了向后兼容而导出数组变量，就不可能将所有内容都保存在一个连续的数组中。附加接口的设计需要反映这一点。

使用符号版本控制，可以导出不同大小的多个版本，而不会更改与特定版本相关联的大小。使用这种模式，新链接的程序将总是使用最新的版本，可能是最大的版本。因为符号版本和大小由链接编辑器同时固定，所以它们总是一致的。GNU C 库对历史变量`sys_errlist`和`sys_siglist`使用这种方法。然而，这仍然不能提供单个连续的阵列。

综合考虑，访问函数(例如上面的`get_external_array`函数)是避免 ABI 兼容性问题的最佳方法。

*Last updated: May 2, 2019*