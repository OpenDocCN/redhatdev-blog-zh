# 2019 年 7 月 ISO C++标准委员会会议报告(并发和并行研究小组)

> 原文：<https://developers.redhat.com/blog/2019/11/15/report-from-july-2019-iso-c-standards-committee-meeting-concurrency-and-parallelism-study-group>

【2019 年夏季 WG21 C++委员会会议于 7 月 13 日当周在德国科隆举行。像往常一样，
红帽派出了三名代表，[核心工作组的 Jason Merrill(CWG)](https://developers.redhat.com/blog/2019/09/03/report-from-july-2019-iso-c-meeting-core-language/)，库工作组的 Jonathan Wakely(LWG)，还有我自己在并发和并行研究组(SG1)。这份较晚的报告涵盖了科隆 SG1 会议，并展望了该会议的一些修订文件，这些文件定于 2019 年 11 月第一周在北爱尔兰贝尔法斯特举行的秋季会议上发表。

## C++20 同步库

在主要全体会议之后，星期一照常开始。本周一开始，SG1 回顾了 C++20 同步原语中一些没有争议的新增内容。其中的第一篇论文是[p 1633 r 0](https://wg21.link/p1633R0)“c++ 20
同步库的修改”，它处理了在 C++20
同步库( [p1135R4)](https://wg21.link/p1135R4) 的措辞审查中发现的一些小问题。这些更改应用于论文的 R5，SG1 投票决定将[p 1135 r 5](https://wg21.link/p1135R5)转发给 LWG。接下来是 [p1643R0](https://wg21.link/p1643R0) 和 [p1644R0](https://wg21.link/p1644R0) ，它们分别提议为 atomic_ref 和
atomic 添加等待/通知功能。SG1 投票决定将这两篇论文都转发给图书馆进化工作组(LEWG)。
午饭前的期末论文是 [p0943R2](https://wg21.link/p0943R2) ，关于 C++中支持 C 原子的问题。SG1 投票决定让论文继续进行，不需要返回做进一步审查。

休息之后，SG1 用两篇论文开始了 stackful co-routines(又名“纤维”)的主题:

*   [P1520](https://wg21.link/p1520R0) “对放大镜下纤维的反应”。""本文试图阐明无栈协同例程和栈满纤程之间的某些区别。
*   [P0876](https://wg21.link/p0876R5) "纤程 _ 上下文-没有调度程序的纤程。"这是将纤程引入 C++标准的一系列建议中最新的一篇(R6)论文。SG1 一致认为 P0876 需要修改才能继续。周五的进一步讨论达成了协议，将技术规范作为该提案的船舶工具，并应用了所要求的更改。

## 实施者

接下来，是每个人最喜欢的话题:遗嘱执行人。第一篇论文 [P1525](https://wg21.link/p1525R0) “单向执行是一种基础很差的操作。”本文支持前面的提议，将 [P1341](https://wg21.link/p1341r0) 中描述的执行者发送者/接收者作为执行者支持的基本操作，其他操作根据发送者和接收者构建，与 [P0443](https://wg21.link/p0443) 的单向执行者概念相反。SG1 的陈述和随后的讨论主要是为周二关于 [p0443](https://wg21.link/p0443) 的讨论提供信息。当天的最后一篇论文是“执行者概念层次需要一个根”本文试图证明，由于 P0443 的执行器概念和添加新概念的机制没有形成包含层次结构，因此很难设计出接受执行器的通用组件。与 [P1525](https://wg21.link/p1525) 一样，这是一个信息演示，用于通知周二关于 [P0443](https://wg21.link/p0443) 的讨论。

周二早上，SG1 开始复习 [P1068](https://wg21.link/p1068) “用于随机数生成的向量 API”这篇文章
建议增加 SIMD 对随机数生成的支持。讨论导致了一个微弱的共识，即这样一个设施应该产生一个 SIMD 类型，如 [N4796](https://wg21.link/n4796) “并行 C++扩展的技术规范”中所描述的本文件的修订版可能会在秋季 WG21 会议上讨论。

接下来是 [P1367](https://wg21.link/p1367) “并非所有代理都有 TLS。”本文建议对 thread_local 的现有实践进行标准化，因为 TLS 使用的实际情况比标准中的措辞甚至允许我们解释的要复杂得多。这是一个相当复杂的话题，SG1 就这个问题进行了广泛的讨论，但在这次会议上没有进行民意测验。

周二下午，SG1 带着 [P1658](https://wg21.link/p1658) “关于执行人共识的建议”继续讨论执行人问题本文提出修改 [P0443](https://wg21.link/p0443) 描述的执行器模型，增加共识，希望执行器按计划与 C++23 合并。折衷的办法是从本质上创建一个单根执行器概念层次结构，增加对 bulk_execute 定制的支持，并引入发送者/接收者概念。妥协留下的主要争议点是错误处理。

然后我们讨论了[p 1791](https://wg21.link/p1791)“[p 0443](https://wg21.link/p0443)统一遗嘱执行人提案的演变，以适应新的要求。”本文的中心前提是 [P0443](https://wg21.link/p0443) 中概述的属性机制能够支持 [P1660](https://wg21.link/p1660) 的发送者/接收者模型的需求。同样，大量的讨论时间花在了应该支持哪种错误通道上。接下来， [P1792](https://wg21.link/p1792) “简化和一般化异步操作的发送方/接收方”认为 [P1341](https://wg21.link/p1341) “在 C++标准库中统一异步 API”的 API 设计方法与现有实践相比存在可用性、灵活性和效率方面的问题。没有进行民意测验；仍然存在很大的意见分歧。当天最后一篇论文是 [P1660](https://wg21.link/p1660) 。经过广泛的讨论，SG1 投票决定将 [P1658](https://wg21.link/p1658) 提议的更改应用到 [P0443](https://wg21.link/p0443) 中，并且像 P1660 中一样对发货错误进行处理是“可以容忍的”。没有达成一致意见继续进行 [P1791](https://wg21.link/p1791) 中的错误
处理。

## 记忆模型主题

周三，SG1 将注意力转向了所有事情的记忆模型，从更新 [P1217](https://wg21.link/p1217) “无中生有，再一次重温”开始接下来， [P1780](https://wg21.link/p1780) “模块化宽松依赖:解决无中生有问题的新方法。”接下来，SG1 审查了 [P1478R0](https://wg21.link/p1478) “字节式原子 memcpy”，这是在 2019 年春季会议上作为草案提交的，本质上是为了编纂大多数 memcpy 实现已经做的事情。运输工具可能是一个技术规范。

周三下午，SG1 审查了 [P1116](https://wg21.link/p1116) “从 shared_ptrs 重新获得独占所有权”，这是一个向 shared_ptr 添加“lock_exclusive()”操作的提议。SG1 认为这是可行的，但不是没有 ABI 破裂，他们不喜欢这个行动的名字。接下来，我们回顾了 [P1726](https://wg21.link/p1726) “指针寿命终结 zap”本文试图将标准中关于对象生命周期结束后指针状态的描述与众所周知的算法相协调，这些算法依赖于能够对生命周期结束的指针执行某些操作。有各种建议来解决这个问题，但在这次会议上没有达成任何结论。

接下来，我们看了 [P0940](https://wg21.link/p0940) “并发 TS 正在增长:并发实用程序和数据结构”和 [P1445](https://wg21.link/p1445) “并发 TS:更新或不更新。”这些论文的讨论大多与发布新技术规范的时间以及它应该基于什么语言标准有关。从这里开始，讨论转移到“澄清原子<线程::id>::compare _ exchange _ *([p 1801](https://wg21.link/p1801))。SG1 投票赞成文件中提出的决议草案。

## 低级 I/O 和更多的执行器

周四上午，SG1 研究了两篇相关论文，它们涉及支持低级 IO 设施和分离对象、将它们运送到其他地方以及恢复对象生命周期的能力。论文分别是 [P1031](https://wg21.link/p1031) “低级文件 i/o 库”和 [P1631](https://wg21.link/p1631) “对象分离和附着”这些文件的范围相当大，甚至只是调查问题，SG1 认为这些建议完全属于 SG1 的职权范围。接下来，SG1 考虑了
[P0652](https://wg21.link/p0652) “具有非同步视图的并发关联数据结构”，该数据结构已根据 SG1 在 2019 年春季会议上的指导进行了更新。SG1 用这种数据类型讨论了各种问题，但是没有进行民意测验。接下来 SG1 看了看 [P1761](https://wg21.link/p1761) “并发地图定制选项”这些并发的数据结构论文很可能会成为一个技术规范。

周四下午，SG1 审阅了一些与执行器相关的论文，从 [P1019](https://wg21.link/p1019) “将执行器与并行算法集成”开始接下来是 [P0797R2](https://wg21.link/p0797r2) “用执行器处理并发异常”，接着是 [P1436R0](https://wg21.link/p1436) “基于亲缘关系执行的执行器属性”人们普遍认为执行器应该支持某种形式的错误处理工具，因为不是所有的代理都支持 C++异常。

## 星期五报纸

SG1 周五早上开始看[p 1382](https://wg21.link/p1382)“volatile _ load<T>和 volatile_store < T >”，这与 [P1152](https://wg21.link/p1152) 的“贬低 volatile”有关接下来是 [P1750](https://wg21.link/p1750) “向 C++标准库添加进程管理的提议。”该提案基于 boost.process 库，它提供了跨平台的流程管理功能，并对如何在标准中支持这一功能进行了大量讨论。一个新版本的 P1750 在贝尔法斯特会议前就可以使用，并且很可能再次出现在 SG1 的议程上。上午的最后一篇论文是“web_view”，它提出了一个利用现有 web 标准和技术的 C++标准库的 web_view 工具。一个新版本的 P1108 已经在贝尔法斯特的邮件中，很可能会再次出现在 SG1 的日程上。

周五下午，SG1 回顾了“异构和分布式计算的系统拓扑发现”在贝尔法斯特会议之前，这份文件的新修订版已经出台，很可能会再次出现在 SG1 的议事日程上。SG1 在科隆讨论的最后一篇论文是 [P0642](https://wg21.link/p0642) “并发调用库”本文的目的是为在 C++中并发调用多个操作提供结构支持。SG1 的反馈是审查 [P1660](https://wg21.link/p1660) 并带回一份新版本的文件，这是贝尔法斯特会议前的一部分，可能会再次审查。

*Last updated: July 1, 2020*