# 2020 年 2 月 ISO C++会议报告(核心语言工作组)

> 原文：<https://developers.redhat.com/blog/2020/04/23/report-from-the-february-2020-iso-c-meeting-core-language-working-group>

2020 年第一届国际标准化组织(ISO) C++会议在捷克布拉格举行。这是我们第一次在布拉格见面，尽管我已经去过那里几次了。我们两个来自 Red Hat 的人参加了会议:Jonathan Wakely 是 ISO C++标准委员会库工作组(LWG)的成员，我是核心语言工作组(CWG)的成员。(这里可以看到 ISO C++委员会结构[。)](https://isocpp.org/std/the-committee)

这是我们在将 C++20 标准草案发送给 ISO C++国家机构征求意见后的第二次会议。我们完成了对上一轮意见的回复。进展顺利，在周末，我们投票决定将最终的 C++20 标准提交给国家机构批准。

在接下来的部分中，我将分享一些决策背后的想法。请注意，这份报告主要解决较低层次的问题，不像我通常的旅行报告。

## 概念

作为我关于[概念](https://en.cppreference.com/w/cpp/language/constraints)工作的一部分，我为解决两个密切相关的问题贡献了文字。

### 澄清申报匹配

第一个问题记录在 [CA104 13.04 [temp.constr]中:阐明声明匹配和需要替换到约束中的部分排序](https://github.com/cplusplus/nbballot/issues/103)。通常，我们尽量避免像 requires-clause 中那样直接代入约束。相反，我们倾向于只在原子约束上进行替换，作为确定需求是否得到满足的一部分。

然而，在比较命名空间范围内的声明和类模板实例中的声明时，我们必须允许在某些情况下进行直接替换。一个例子是确定专门化是否匹配:

```
template <class T> struct A {
    template <class U> U f(U) requires C<typename T::type>;
    template <class U> U f(U) requires C<T>;
  };

// Substitute int for T in above requirements to find match.
  template <> template <class U> U A<int>::f(U) requires C<int>  { }

```

### 隐藏的非模板好友

第二期来自[us 115 13 . 6 . 4【temp . friend】:隐藏的非模板好友需要一个 requires-clause](https://github.com/cplusplus/nbballot/issues/114) 。到目前为止，非模板友元声明包含 requires-clause 被认为是不良的。ISO C++委员会认为，不清楚非模板友元声明是试图匹配给定的约束重载，还是试图仅在满足要求的情况下声明友谊。我们认为移除对非模板函数的约束会使第一个问题变得毫无意义。第二个关注点仍然是与所有其他情况下的约束语义的不良区别。

如果 friend 是在类体中定义的，那么 requires-clause 就像在成员函数中一样有意义。也就是说，根据模板参数的特征，子句可用于定义类模板的特定操作。该库已经允许这种行为，即使语言说这是无效的。

我们决定允许在模板化类中定义的友元上使用 requires-clause。为了避免部分专门化匹配所需的那种替换(如代码示例所示)，我们说过，任何带有依赖于类的模板参数的约束的友元模板也必须在类体中定义。如果约束只依赖于朋友的模板参数，那么它可以是一个声明，以匹配在名称空间范围内定义的模板。

### 改变观念价值观

继续概念，我们提到了 *[不允许改变概念值](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2104r0.html)* 。本文将 GB046 解析为“接受修改”

我们注意到，在 G++编译器中处理概念时，草案允许声明的满意度在翻译单元内变化。这意味着，例如，一个声明可以通过一个类变得完整来满足。支持这种改变会降低编译器的速度，因为我们不再记得以前检查事件的结果，比如完成一个类定义。不允许改变概念值的决定意味着我们不必担心这个问题，我们可以再次加快编译器的速度。作为一个警告，目前的决议打破了相当数量的概念代码，所以需要更多的调查。

### 函数模板约束

对于 2019 年评论 CA 112 、的 *[建议决议，我们决定澄清，如果模板参数在其他方面等同，则函数模板只能被视为比另一个更受约束。](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2113r0.html)*

## 模块

我们提出了三个建议，处理曾经是翻译单位的本地实体的复杂性。在模块接口单元中，这些实体对于导入翻译单元来说是可见的:

*   *[p 1815 r 2:Translation-unit-local entities](http://wg21.link/p1815r2)*使一个导出的声明暴露一个翻译本地实体的形式不正确。
*   *[P1779R3:成员函数的 ABI 隔离](http://wg21.link/p1779r3)* 使得定义在一个模块内的类体中的函数不再隐式*内联*，这样它们就可以使用局部实体而不用暴露它们。
*   [*P2115R0:未命名未分类枚举的多个定义的合并*](http://wg21.link/p2115r0) 讲述了我们如何从头文件中合并未命名的文件范围枚举，这些头文件在不同的翻译单元中可能没有相同的枚举器集。

这些模式之前都违反了*的一个定义规则* (ODR)，但在实践中有效。注意，编译器可以自由地内联一个没有声明`inline`的函数，所以 P1779 的变化不会影响性能。在诸如 GNU/Linux 这样的 ELF 目标上，允许符号被其他定义覆盖，GNU 编译器集合(GCC)目前不内联可替换函数，除非用户指定`-fno-semantic-interposition`。我们可以在 GCC 模块实现中解决这个问题，方法是假设模块接口单元中定义的函数没有插入。

## 多方面的

我们还讨论了几篇杂七杂八的论文。其中之一， [*P0593R6:* 用于低级对象操作的对象的隐式创建](http://wg21.link/p0593r6)，提供了一个新的模型，当对象被认为已经在`malloc` ed 存储器或`char`缓冲区中创建时。任何必需的对象都被认为是通过`malloc`或创建缓冲区隐式创建的。新的模型应该会使 C++中基于类型的别名规则更加清晰。

我们还提出了建议 *[P1957R2:从 T*到 bool 的转换应该被认为是收缩](http://wg21.link/p1957r2)* 。令人惊讶的是，我们以前没有考虑到指针到 bool 的转换是收缩的；然而，实验表明，做出这种改变会导致比误报更多的错误。

对 *[P1937R2:修复 constexpr 和 consteval 函数](http://wg21.link/p1937r2)* 之间的不一致的解决方案声明`consteval`调用不能在未求值的上下文中立即求值。

## 结论

下一次会议定于 2020 年 6 月在保加利亚瓦尔纳举行。由于新冠肺炎，它被无限期推迟。

*Last updated: June 29, 2020*