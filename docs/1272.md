# SCTP 流调度器和用户消息交错

> 原文:[https://developers . red hat . com/blog/2018/01/03/SCTP-stream-schedulers](https://developers.redhat.com/blog/2018/01/03/sctp-stream-schedulers)

有些人可能已经注意到，最近发布了一个关于流控制传输协议(SCTP)的新的征求意见稿(RFC)， [RFC8260](#rfc8260) 。该 RFC 定义了 SCTP 协议的两个主要变化，最初在 [RFC4960](#rfc4960) 中定义:

1) **流调度器**，当通过线路发送数据块时，它控制下一个服务的流。
2) **I-Data** chunk，它扩展了数据以克服它的一些限制。

这篇博客文章将回顾这两个变化，指出使用流调度器的好处，尤其是当它们与新的 I 数据块一起使用时。

但首先让我们回顾一下 SCTP，它是一种传输协议，最初是为电话信令设计的，继承了传输控制协议(TCP)的一些功能和行为，也继承了用户数据报协议(UDP)的一些功能和行为。它是面向连接的协议，如 TCP，但也是面向消息的，如 UDP。它支持完全可靠性，如 TCP，但也支持部分可靠性，更像 UDP，以及其他功能。

对于本博客的上下文来说，重要的是要知道单个 SCTP“关联”(或 TCP 术语中的“连接”)可能包含多个“子流”，这些子流被称为“流”。这些流是相互独立的，它们的工作是复用关联。“用户消息”是由应用程序发送的任何消息。消息必须封装在“数据块”中，然后才能通过流传输。用户消息由一个或多个数据块组成，以防其大于路径最大传输单元(PMTU)并且需要分段。一个数据块绝不会包含多于一条用户消息(的一部分)。

将使用的缩略语:

*   **FSN** :片段序列号
*   **MID** :报文标识符
*   **SSN** :流序列号
*   **TSN** :发送序列号

## 流调度程序

一个 SCTP 协会可能有多个独立的流流动。例如，一个应用程序可以有 5 个入站流和 3 个出站流，它们都是独立的。假设应用程序在流#1 中发送了一个带有 SSN 1 和 TSN 1 的数据块，在流#2 中发送了一个带有 SSN 1 和 TSN 2 的数据块。如果 TSN 为 1 的数据块丢失，而 TSN 为 2 的数据块通过，后者可以传递给应用程序，因为该流的序列是完整的。

这看起来不错，但是有一个很大的限制:如果由于某种原因，应用程序需要将流#1 上的流量优先于流#2 上的流量，该怎么办？一个例子是视频流，其中应用程序可以通过流#1 发送关键帧，并在流#2 中发送交错帧。在带宽突然减少的情况下，该协议可以首先从流#2 开始丢弃块，并试图保持流#1 上的流，即使对于那些已经在套接字中排队的块也是如此。

在 [RFC8260](#rfc8260) 之前，SCTP 堆栈通常以先来先服务(FCFS)的方式提供流服务。由应用定义的传输顺序将保持不受影响，并且流主要仅用于复用目的。下图显示了 FCFS 的一个示例。假设应用程序首先在流#0 上发送消息，然后在流#2 上发送，然后才在流#1 上发送。

```
+---+---+---+
|    0/0    |-+
+---+---+---+ |
              |  +---+---+---+---+---+---+---+---+---+
+---+---+---+ +->|1/2|1/1|1/0|2/0|2/0|2/0|0/0|0/0|0/0|
|1/2|1/1|1/0|--->|---|---|---|---|---|---|---|---|---|
+---+---+---+ +->| 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
              |  +---+---+---+---+---+---+---+---+---+
+---+---+---+ |
|    2/0    |-+
+---+---+---+
                               +-------+
  +-------+                    |SID/SSN|
  |SID/SSN|                    |-------|
  +-------+                    |  TSN  |
                               +-------+
```

在此示例中，有三个流，由左侧的方框表示，SID 分别为 0、1 和 2。请注意流#1 上的消息必须等待流#0 和流#2 上的消息被传输。但是如果它们对应用程序更重要呢？

这就是流调度程序发挥作用的地方:应用程序现在能够要求 SCTP 堆栈选择不同于 FCFS 的调度算法。

由 [RFC8260](#rfc8260) 定义的调度器集合代表了最常用的网络数据包调度器，包括:

1.  先来先服务调度程序( SCTP_SS_FCFS
2.  循环调度程序( SCTP_SS_RR )
3.  每个数据包的循环调度程序( SCTP_SS_RR_PKT
4.  基于优先级的调度程序( SCTP_SS_PRIO
5.  公平容量调度程序( SCTP_SS_FC
6.  加权公平排队调度程序(SCTP _ WFQ

Linux 栈目前只支持 FCFS、RR 和 PRIO。RR_PKT、FC 和 WFQ 尚未实现，尽管实现应该相当简单。

请参考 RFC 以了解如何使用这些调度程序。所有需要的选项都在那里描述了，Linux 也遵循了它们。

下图显示了一个没有用户消息交错的循环调度器示例(也由 [RFC8260](#rfc8260) 定义，将在下一节描述):

```
+---+---+---+
|    0/0    |-+
+---+---+---+ |
              |  +---+---+---+---+---+---+---+---+---+
+---+---+---+ +->|1/2|1/1|2/0|2/0|2/0|1/0|0/0|0/0|0/0|
|1/2|1/1|1/0|--->|---|---|---|---|---|---|---|---|---|
+---+---+---+ +->| 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
              |  +---+---+---+---+---+---+---+---+---+
+---+---+---+ |
|    2/0    |-+
+---+---+---+
                               +-------+
  +-------+                    |SID/SSN|
  |SID/SSN|                    |-------|
  +-------+                    |  TSN  |
                               +-------+
```

在此示例中，有三个流，由左侧的方框表示，SID 分别为 0、1 和 2。流#0 和#2 有一个大消息排队(SSN 为 0)，三个较短的消息计划在流#1 上发送(SSN 为 0、1 和 2)。输出管道和调度结果显示在右侧。在不支持[用户消息交错](#user-message-interleaving)的情况下，注意在发送来自流#1 的小块之前，它必须如何传输来自流#0 的整个消息。这就是新数据块格式的优势所在。

由于这种改变只影响发送方，并且是向后兼容的，所以即使对方不知道，对等体也能够利用流调度。

## 用户消息交错(I 数据块)

在上面的例子中，如果流#1 比流#0 具有更高的优先级，但是它的消息在流#0 之后排队(例如，被另一个线程排队)，将会发生行首阻塞情况。这是因为来自流#1 的块必须等待来自流#0 的块被发送(但不一定被确认)。只有这样，来自流#1 的块才能被传输。

这是因为 TSN 字段实际上在数据块中有三个不同的用途。引用 [RFC8260](#rfc8260) ，TSN 字段可以:

*   作为数据块的标识符，以提供可靠的传输。
*   作为片段序列的标识符，以允许重组。
*   作为序列号，允许多达 2**16 - 1 个未完成的流序列号(SSN)。

再次注意，该协议要求用户消息的所有片段具有连续的 tsn。

新的 I-Data 区块通过不使 TSN 字段过载来解决这个行首阻塞问题。相反，添加了两个新字段(中部和 FSN)并删除了 SSN 字段。MID(消息标识符)现在用于标识给定用户消息的所有块，还用于确保流内的有序传递。片段序列号(FSN)字段仅在需要对用户消息进行分段时使用，并且是仅与该用户消息相关的序列号。因此，所有片段使用相同的 MID 号。TSN 字段现在仅用于确保可靠性。

有了这些改变，现在可以先占流#0 的传输，以便发送其他插入消息。如果我们现在在上一个示例的基础上引入新的 I 数据块，消息将按如下所示进行调度:

```
+---+---+---+
|    0/0    |-+
+---+---+---+ |
              |  +-----+-----+-----+-----+-----+-----+-----+-----+-----+
+---+---+---+ +->|2/0/2|1/2/0|0/0/2|2/0/1|1/1/0|0/0/1|2/0/0|1/0/0|0/0/0|
|1/2|1/1|1/0|--->|-----|-----|-----|-----|-----|-----|-----|-----|-----|
+---+---+---+ +->|  8  |  7  |  6  |  5  |  4  |  3  |  2  |  1  |  0  |
              |  +-----+-----+-----+-----+-----+-----+-----+-----+-----+
+---+---+---+ |
|    2/0    |-+
+---+---+---+
                                     +-----------+
  +-------+                          |SID/MID/FSN|
  |SID/MID|                          |-----------|
  +-------+                          |    TSN    |
                                     +-----------+
```

请注意流#0 (TSN #0、#3 和#6)上的消息#0 的发送如何被中断，以便从其他流发送消息。

但是与流调度器不同，这个新块的使用必须在握手期间协商。一旦协商，就不能对该关联进行更改。这意味着一个关联要么使用旧的数据块，要么使用新的 I-Data，但不能同时使用两者。谈判遵循通常的方案。请求者宣传其对这个新方案的支持，以及使用它的意图。如果被请求的对等体也表示支持这种操作模式，则对等体必须仅使用 I 数据块。否则，双方必须退回到旧的数据块。

## 参考

> RFC8260
> 
> Stream Schedulers and User Message Interleaving for the Stream Control Transmission Protocol, [https://tools.ietf.org/html/rfc8260](https://tools.ietf.org/html/rfc8260)
> 
> RFC4960
> 
> Stream Control Transmission Protocol, [https://tools.ietf.org/html/rfc4960](https://tools.ietf.org/html/rfc4960)
> 
> * * *
> 
> **利用您的红帽开发者会员资格和** [**免费下载 RHEL**](http://developers.redhat.com/products/rhel/download/) **。**

*Last updated: January 2, 2018*