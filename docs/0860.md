# 2019 年 2 月 ISO C++会议报告(核心语言工作组)

> 原文：<https://developers.redhat.com/blog/2019/04/11/report-from-the-february-2019-iso-c-meeting-core-language-working-group>

2019 年 2 月 [ISO C++会议](https://isocpp.org/std/meetings-and-participation/upcoming-meetings)在夏威夷凯卢阿-科纳举行。像往常一样，Red Hat 派出了三名开发人员参加会议:我参加了核心语言[工作组](https://isocpp.org/std/the-committee)，Jonathan Wakely 参加了图书馆，Thomas Rodgers 参加了 SG1(并行和并发)。会议进行得很顺利，尽管开始时我们最终会走到哪里还存在很大的不确定性。最终，C++20 草案接受了模块和协程，所以现在我们有工作要做了，我们要钉上剩下的松散的角落。以下是会议要点。

### [模块](https://wg21.link/P1103R3)

目前，模块方面的工作仍在继续。Evolution group 周二的所有讨论，以及本周晚些时候的一些讨论，都是关于模块的各种微妙之处，尤其是关于基于参数的查找。周一晚上的讨论还涵盖了工具方面的挑战。我没有密切关注设计讨论，因为 Nathan Sidwell 负责 GCC 中的模块，但看起来我们正在集中于一个可靠的设计，用各种概念证明来解决问题。全局模块碎片仍然让我紧张，但是现在我们也有了头单元，我很满意这不会是一个大问题。

### [协程](https://wg21.link/P0912R5)

协同程序占据了整个周三的进化课。除了在过去的会议中已经讨论过的协程 TS 和核心协程提案之外，还提出了第三种设计，称为“对称协程”对不同的方法进行了大量的比较——比较不同提案做出的不同选择，并考虑它们之间未来趋同的可能性。最终，Evolution 投票决定继续协程 TS 的设计。

### [合同](https://wg21.link/p0542r5)

在早些时候的一次会议上，合同被投票纳入 C++20，但是这个话题仍然占据了整个星期一。有两个相互竞争的提议来解决一些人的紧张情绪，他们担心“假设”一个合同条件会影响包括该合同在内的执行路径的优化。

在我看来，如果你有可以继续的契约，那些条件就不能被后续代码所假定。但是，如果契约检查无法继续，那么检查自然可以由后续代码来承担，因为如果它为 false，执行就不会继续。因此，一个条件能否被假定的问题就归结为检验能否继续。这两个提案都希望增加对此的显式控制，一个是通过向构造函数添加“continue”关键字，另一个是通过引入显式语义，如使用 check_maybe_continue 来代替契约级别，如“default”。我相信在下次会议上我们会看到更多关于这方面的内容。

还有人担心假设条件的反向传播，这种假设条件基于现有的措辞，即可能失败的未经检查的契约是未定义的行为；编译器基于未定义行为不会发生的假设进行优化，并相应地将代码标记为不可访问。我认为这种担心被夸大了，因为未定义条件的反向传播已经在大多数优化器中发生了(例如，空指针取消引用),这只会使条件更加清晰。检查的契约不会反向传播，因为契约处理程序可能不会返回。

一项建议是将"期望"/"确保"改为"预先"/"事后"；这个建议很受欢迎，可能会在下次会议上讨论。

### 反射

Core 花了一段时间对国家机构关于[反思 ts](http://wg21.link/N4766) 的评论做出回复，修改后的 TS 被批准出版。目前还不清楚这种反射方法(使用魔法类型)是否会成为标准的一部分，但是我们认为在这一点上它已经被很好地指定了。

以下是一些比较小的报纸:

扩展结构化绑定( [P1091R3](https://wg21.link/p1091r3) ， [P1381R1](https://wg21.link/p1381r1) )，允许将结构化绑定声明为 static 和 thread_local，并由 lambdas 捕获。

[允许从带括号的值列表](https://wg21.link/P0960R3)初始化聚合，所以现在所有的聚合类都可以使用调用构造函数的正常语法初始化，具有相似的语义。例如，在构造函数调用中，不会扩展引用成员的临时绑定，也不会省略大括号。这是为了支持像 make_unique 这样的库对象工厂函数的使用。

新表达式中的数组大小推导，允许`new T[]{ ... }`从初始化式中推导出分配数组的大小，就像我们已经对变量做的那样。

[< = >！===](https://wg21.link/P1185R2) ，为了提高效率，它将默认的运算符= =改为使用成员= =而不是< = >。

以下是我们看过的其他一些论文，它们在本周还没有准备好:

[填补类模板参数演绎](http://wg21.link/P1021R3)中的漏洞，它建议允许聚合、别名模板和继承构造函数的 CTAD。

[条件平凡的特殊成员函数](http://wg21.link/P0848R1)，其目的是允许具有某些(概念)约束的构造函数是平凡的，而具有不同约束的构造函数不是平凡的，并且使类是否是平凡可复制的取决于为该类的特定实例化选择哪个。

下一次会议将于 7 月在德国科隆举行。

*Last updated: April 10, 2019*