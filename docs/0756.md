# 2019 年 2 月 ISO C++会议报告(图书馆)

> 原文：<https://developers.redhat.com/blog/2019/07/16/report-from-the-february-2019-iso-c-meeting-library>

回到二月份，我参加了在多雨的夏威夷科纳举行的 [WG21 C++标准委员会会议](https://isocpp.org/std/meetings-and-participation/upcoming-meetings)(是的，一周的大部分时间都在下雨)。这份报告提交得太晚了，我们现在正在准备下一次会议，会议将于 7 月中旬在科隆举行。

像往常一样，我大部分时间都在图书馆工作组(为 LWG 有关各个工作组和研究小组的详细信息，请参见[标准 C++:委员会](https://isocpp.org/std/the-committee)。LWG 的目的是形式化 C++标准库的规范，即 C++标准的第二个“一半”(尽管就页数而言，它更接近四分之三而不是一半)。随着新的 C++20 标准的出现，以及人们希望添加到标准库中的许多新特性，LWG 一直忙于处理库发展工作组(LEWG)提交的积压的新提案。

科纳会议的主要任务之一是审查“[靶场设计清理](https://wg21.link/P1252R2)提案。这次清理涉及到对新的 Ranges 库的许多修复和改进，解决了在审查以前(更大的)添加 Ranges 库的建议时出现的问题，这是 C++20 库的最大添加之一(C++20 的大多数其他重要添加都会影响核心语言，对库没有太大影响)。事实上，我可以说这是自 1998 年第一个标准以来 C++标准库最大的补充之一。Ranges 库工作彻底检查了源于标准模板库(STL)的标准部分，即迭代器、算法和容器，根据 C++概念重新指定它们。这是一个多年的努力，在 LWG 的多次提议和几次措辞审查会议之后，现在已经落在了 C++20 工作草案中。

议程上的另一个项目是 C++20 同步库。这是一篇综合论文，结合了几个早期关于新同步原语的提议，比如等待原子变量、信号量、锁和屏障。因为它是不同作者在不同时间写的提案的组合，措辞相当不一致，提案的不同部分试图以完全不同的方式表达相同的事情。我们发现措辞存在许多问题，并要求作者修改提案并将其带回。就我个人而言，我认为很不幸的是，独立提案被合并，因为一些部分状态良好，本来可以向前发展，但现在提案中的一切都在等待几个部分得到修复。

我们还花了很多时间来复习标准的`flat_map`[。这是一个新容器的提议，它有一个类似于`std::map`的 API，但是将数据存储在一个类似数组的结构中，而不是一个二叉树。当前的提议是一个容器适配器，这样你就可以从一个`std::vector`，或者`std::deque`，或者其他容器创建一个 flat_map。从第一个版本开始，这个提议已经被修改了，这样一个`flat_map`为键和值使用了单独的容器；因此，所有的键被打包到一个数组中，所有的值被打包到另一个数组中，从而提高了键的引用局部性。将键和值分开的缺点是指定起来更困难，LWG 审查揭示了许多异常安全问题。我们对措辞做了许多改进，并阐明了在极端情况下实施可以保证什么。在某些情况下，如果操作失败，保留不变量的唯一合理方法是完全清除容器，以将其恢复到已知状态。我不相信将键和值分开的好处大于坏处。LWG 将再次审核更新后的提案，我很高兴在最近的邮件中看到“当前`flat_map`提案](https://wg21.link/P0429R7)的[问题”一文，其中讨论了当前设计的一些缺点。](https://wg21.link/P1727R0)

## 强制标准库

在 Kona 会议上，以及在会议间隙，我们还审查了 Marshall Clow(LWG 主席)关于同一主题的一系列提案，“强制标准库”(这是一个双关语，因为我们现在在规范中使用标签“*强制*”来描述静态强制的前提条件)。四年前，在“[分离库需求和先决条件](https://wg21.link/P0411R0)”中，我第一次尝试解决这个问题，这是我最关心的话题目的是重新分类标准库中的每个前提条件，以便那些可以在编译时静态检查和执行的前提条件将导致编译失败，而不是任意的未定义行为。从历史上看，标准库只是说违反它的大多数前提条件是未定义的，即使在实践中违反诸如“模板参数 T 是可复制构造的”这样的要求将无法编译，而不是调用可怕的“未定义行为”

在标准的下一个版本中，用户将能够清楚地区分将导致编译失败的需求和必须满足的前提条件，以避免您的打印机着火或魔鬼从您的鼻子里飞出。在 Kona，我们回顾了该系列的第一篇论文，涵盖了[条款 16 -语言支持库](https://wg21.link/P1458R1)、[条款 18 -诊断库](https://wg21.link/P1459R1)、[条款 20 -字符串库](https://wg21.link/P1462R1)、[条款 21 -容器库](https://wg21.link/P1463R1)和[条款 22 -迭代器库](https://wg21.link/P1464R1)。在即将到来的科隆会议上，我们将审阅论文，为[原子操作](https://wg21.link/P1505R1)、[线程支持](https://wg21.link/P1622R1)、[时间库](https://wg21.link/P1686R0)、[算法](https://wg21.link/P1718R0)、[数字运算](https://wg21.link/P1719R0)、[本地化](https://wg21.link/P1720R0)、 [I/O](https://wg21.link/P1721R0) 、[正则表达式](https://wg21.link/P1722R0)和[原子操作](https://wg21.link/P1723R0)做同样的事情(是的，这有两篇论文如果我们在科隆读完了所有这些，那就应该包括所有的图书馆条款了。然后我们只需要确保新的提议使用新的规范风格，这样我们就不会添加回任何旧的“一切都是未定义的行为！”前提条件。

我们还审查(并批准了)“[对数字和指针](https://wg21.link/P0811R3)的良好插值”，它向库中添加了`std::midpoint`和`std::lerp`。令人惊讶的是，这些函数很难在所有的极限情况下都正确，关于如何实现它们的讨论在会后很久还在继续。事实上，即使领域专家(以及像我一样试图实现它们的非专家)也很难把它们做好，这使得它们成为标准库中的完美候选。最好让几个编译器供应商处理一次这个问题，而不是让成千上万的用户一遍又一遍地编写它们，要么产生微妙的错误，要么重复工作来正确处理所有的问题。

我们还审查(并批准了)"[有符号`ssize()`函数，无符号`size()`函数](https://wg21.link/P1227R2) " (P1227R2)，这解决了一个引起激烈争论的有争议的话题。标准库中的容器使用无符号类型(通常是`size_t`)来表示大小和索引。人们普遍(但不是普遍)认为这是一个错误，应该使用有符号类型。使用有符号类型(例如，POSIX 的`ssize_t`而不是`size_t`)使得检测溢出更加可靠，因为杀毒程序和断言可以判断正值何时溢出为负值。检测无符号值何时换行更加困难，因为这是由语言规则明确定义的——无符号类型不能溢出，而是换行。当“一个非常大的值”明显地*太*大并且是由于一个 bug 时，并不总是可能辨别出来的(然而一个负的索引到一个`std::vector`总是错误的)。

当`std::span`类模板第一次被添加到 C++20 草案中时，它打破了传统，使用了有符号类型。这引起了一些恐慌，甚至在那些认为有符号类型在理论上是更好的选择的人中，因为许多人认为与库中其他类型的一致性更重要(更多信息见 [P1089R2](https://wg21.link/P1089R2) )。P1227R2 采取的折衷方法是一致地使用无符号类型，但是添加了一个新的`ssize()` free 函数，该函数可用于获得作为有符号类型的容器的大小。这可能不是我们最后一次听到这个话题，但我们现在似乎达成了共识。

## 其他论文

我认为这些是 LWG 处理过的最有趣的文件。如果您感兴趣的话，这里没有提到的下列论文也被批准包含在 C++20 中:

*   [使 std::underlying_type SFINAE 友好](https://wg21.link/P0340R3)
*   [我流，你流，我们都为 istream_iterator 流](https://wg21.link/P0738R2)
*   [让 create_directory()变得直观](https://wg21.link/P1164R1)
*   [来自并行 V2 TS 的矢量化策略](https://wg21.link/P1001R2)
*   [STD::span](https://wg21.link/P1024R3)的可用性增强
*   [查找中预先计算的哈希值](https://wg21.link/P0920R2)
*   [有界数组的特征](https://wg21.link/P1357R1)

GCC 对 C++20 库的实验性支持的状态在 [libstdc++文档](https://gcc.gnu.org/onlinedocs/libstdc++/manual/status.html#status.iso.2020)中被跟踪。

当讨论我感兴趣的论文(或者帮助作者)时，我也在 LWG 房间外进行了几次短暂的旅行。

在 LEWG 的孵化器里，我参加了另一场关于 [`colony`](https://wg21.link/p0447r4) 提案的讨论，我之前已经写过了。它仍然有一些支持者认为它是有趣和有用的(包括我自己)，但其他人想要更多的理由。最近一次审查的结果是，人们希望这种相当新颖的数据结构能够完全满足实际需求(而不是几乎成为人们需要的*，但是差异太大，以至于他们实际上无法使用)。该提案没有取得进展，但它肯定也没有死亡，我们将再次看到它。我还参加了一些 LEWG 孵化器对网络 TS 问题的讨论(我是项目编辑)。我们有 Boost 的作者。Asio 和网络 TS 到场回答了 [P1100](https://wg21.link/P1100) 、 [P1133、](https://wg21.link/P1133)和 [P1145](https://wg21.link/P1145) 中提出的问题，这很有用。正在研究解决这些问题的替代方案。*

 *我还参加了 EWG 孵化器的一个会议，我与人合著了一篇论文，提出了一种语言扩展来简化元组和类似结构中的参数包。这篇论文没有继续，但也没有死，很可能会回来进行另一轮讨论。

最后，我参加了关于 [`source_location`](https://wg21.link/P1208R1) 的 LEWG 讨论，然后在本周晚些时候参加了 LWG 对该提案的审查(在那里它陷入了签署/未签署的讨论，这在最近发生了很多，见上面的 P1227R2。)

科纳报告到此为止。本月晚些时候，我将在科隆参加下一次会议。科隆 LWG 议程包括一个更新的`flat_map`提案，以及对其同伴提案`flat_set`的第一次审查，以及对上面讨论的 C++20 同步提案的更新。

### 阅读更多

【2019 年 2 月 ISO C++会议报告(核心语言工作组)

【2019 年 2 月 ISO WG21 C++标准委员会会议报告

*Last updated: July 15, 2019**