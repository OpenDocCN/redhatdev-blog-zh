# 2018 年秋季 ISO WG21 C++标准委员会会议行程报告

> 原文:[https://developers . red hat . com/blog/2019/01/10/fall-2018-iso-wg21-c-standards-Committee-meeting-trip-report](https://developers.redhat.com/blog/2019/01/10/fall-2018-iso-wg21-c-standards-committee-meeting-trip-report)

秋季 C++会议在加州圣地亚哥举行。像往常一样，Red Hat 派了我们三个人去参加会议:我来自并发和并行研究小组(SG1)，Jason Merrill 来自核心语言工作组，Jonathan Wakely 来自库工作组(LEWG)。

SG1 有一个相当满的盘子，但结束了一周，有一点喘息的空间。这篇文章描述了本周在 SG1 讨论的主要话题。

## 可协作中断的连接线程，也称为“jthread”

这一提议已经流传了一段时间，最近一次是在 9 月 CppCon 附近的 SG1/LEWG 会议上。在那次会议上，SG1 的指导方针是删除 TLS，抛出等待函数，并增加支持让 jthread 调用一个可调用函数，该可调用函数要么接受一个中断令牌作为附加的第一个参数，要么不接受任何中断令牌。该提案的作者尼科·乔舒蒂斯、赫伯·萨特和安东尼·威廉姆斯将修改后的论文带到了圣地亚哥。Nico 没有出席贝尔维尤会议，并希望进一步讨论这个问题，因为作者有一些新的经验。

注意到中断 `std::condition_variable`等待是很棘手的，但是在至少有三个库实现的情况下，`std::condition_variable_any`更容易中断，并且可以“做正确的事情”,而用户不能从谓词中做。

关于添加一个回调机制来中断令牌，也有一个重要的讨论。有人担心，如果这种机制不是 C++20 中断令牌机制的一部分，可能会出现 ABI 问题。

本周晚些时候，SG1 回顾了 [p1287R0](https://wg21.link/p1287r0) ，`interrupt_token`的异步用例。这是周一讨论 p0660R5/p0660R6 的延续。SG1 利用具有回调机制的中断令牌探索了潜在的步兵射击。剩下的讨论集中在 p1287R0 提出的回调设计上。

SG1 投票决定“p0660R6 和 p1287R0 的一些合并版本”可以从 SG1 的魔掌中解放出来，等待未来会议上的措辞审查。

在`libstdc++`中，我已经开始研究这个功能的实验版本。

## 实施者

SG1 将周一和周二的大部分时间用于讨论各种与遗嘱执行人相关的文件。

首先是 C++统一执行人提案的修订版 9，又名 [p0443R9](https://wg21.link/p0443r9) 。在进行了许多澄清性的讨论以及关于`bulk_execute`是否应该成为 C++执行程序的一部分的讨论之后，带有`bulk_execute`的 p0443 执行程序也被从 SG1 的魔掌中释放出来，等待未来会议的审查。

在 9 月的贝尔维尤会议上，决定将 p0443 的所有相关执行特性拆分到一份不针对 C++20 的单独文件中。根据贝尔维尤的要求，论文以 [p1244R0](https://wg21.link/p1244r0) 的形式提交。

您可能想对执行器做的一件明显的事情是让它们与标准库算法集成。SG1 花了一些时间讨论了与这个主题相关的几篇论文:

*   [p1019R1](https://wg21.link/p1019r1) :集成并行算法执行器
*   [p1232R0](https://wg21.link/p1232r0) :通过定制将执行器与标准库集成
*   [p1194R0](https://wg21.link/p1194r0) 经验报告:用并行算法集成执行器
*   D1348R0:供执行代理占用的执行人财产

p1019R1 的介绍为本文之前的讨论带来了新的材料，特别是为了解决一个长期存在的问题，即“我们有遗嘱执行人；为什么我们还需要执行策略？”对 p1019R1 的讨论探索了这种新材料，但在这次会议上没有得出结论或明确的方向。

P1232R0 提出 p0443R9 的设施不足以覆盖代表 GPU 以外的加速器(例如 FPGAs)的执行资源的需求。该论文提出本质上使每个接受`execution_policy`的标准算法也支持 [n4381](https://wg21.link/n4381) (又名“ranges-style”)扩展点。

P1194R1 是探索在 p0443R9 和 p1019R1 方面实现现有并行算法所涉及的内容的初步尝试。本文主要是为了提供信息；我真的没想到会展示出来。尽管如此，SG1 还是安排了对它的讨论，这个讨论在很多方面是对 p1232R0 的讨论的延续。我从讨论中得出的一般结论是，我们仍然不知道如何通过 p1019 的`.on()`机制来提供任意的执行者，并且需要做更多的工作来理解如何进行。

在圣地亚哥没有讨论的是执行者和网络的集成，另一个明显的用例。Chris Kohlhoff 带来了一篇论文，修改了网络技术规范，以允许自定义 I/O 执行器 p1322R0。Detlef Vollmann 还带来了一篇论文，建议将“大多数”网络 TS 合并到 C++工作草案中。由于 LEWG 拒绝向 C++20 IS 推进网络，这两篇论文都没有在本周讨论。

## 圣地亚哥会议期间在 SG1 讨论的小论文

*   [P1258R0](https://wg21.link/p1258r0) 不要让 C++在小型 CPU 上无法实现:本文是对 Rapperswil 会议上做出的一项决定的回应，该决定要求即使在独立的 C++实现中也必须至少有一个无锁原子整数类型。这对于某些不提供`atomic compare_exchange`指令的合理的现代 CPU 来说是有问题的。这篇文章引发了一场关于我们应该如何对待独立 C++实现的额外的晚间讨论。
*   一个侵入性的智能指针:我没有参加这篇文章的讨论，但似乎已经达成共识，将它转移到 C++23。
*   [P0335R1](https://wg21.link/p0335r1) 并行算法的上下文令牌:提出了一种通过执行策略定制并行算法元素访问函数的选择加入机制。我自愿为`libstdc++`构建一个实现原型，为本文的未来讨论提供信息。
*   [P0918R2](https://wg21.link/p0918r2) 更多`simd<>`运算:本文提出从 N4755 扩展一套可移植定义的 SIMD 运算。SG1 倾向于将 P0918R2 中的操作包含在由 LEWG 确定的`simd<>`操作(IS 或 TS)的下一个运输工具中。
*   [P1241R0](https://wg21.link/p1241r0) 支持将协同程序合并到 C++20 中:我没有参加这篇论文的讨论，也没有会议记录(有讨论吗？).另请参阅后面关于协程状态的全体会议注释。
*   [P1205R0](https://wg21.link/p1205r0) 通过`co_await`传送:这篇论文和对它的讨论的要点是协程可以在一个执行代理上暂停，在另一个执行代理上恢复——这可能是非常令人惊讶的情况。这可能会产生相应的令人惊讶的后果(例如，一旦协程恢复，TLS 就不一样了；协程在一个信号处理程序中被恢复，对什么是“安全”做的有非常不同的约束，等等。).本文建议澄清协程的措辞，使协程*的这种用法由实现定义*。
*   协程概念和元函数:本文提出了新的概念定义、类型特征和标准库的助手，以支持使用协程对可应用类型进行泛型编程。本文为 P1316R0 和 P1171R0 提供支持/概念基础。
*   [P1316R0](https://wg21.link/p1316r0) 协程的一个`when_all()`操作符:这个提议允许等待多个`co_await` awaitables。对这个房间的感觉是一种“对 C++的渴望(最终) ...
*   [P1171R0](https://wg21.link/p1171r0) 同步等待异步操作:这提议为协程增加一个`sync_wait()`操作符，允许任意 awawait 被`co_await` ed。
*   C++中的管道支持:我没有参加本文的讨论。在我看来，弄清楚 P1244R0、P1288R0、P1316R0 和 P1171R0 使 C++朝着构建类似管道的设施的一组词汇类型前进了一大步。
*   [P1152R0](https://wg21.link/p1152r0) 反驳`volatile`:这篇论文的标题很好地概括了它的内容。讨论和投票主要是关于论文作者 JF·巴斯丁要求的后续论文修改的指导。
*   不对称围栏:SG1 有兴趣将其作为未来并发性 TS 的一个方向进行探索，并接受进一步的措辞审查。

## LEWG 和网络 TS

在圣地亚哥会议之前，曾经有一些希望网络 TS 会被投票从 LEWG 中淘汰出来，转向 C++20 草案标准。这并没有发生，因为 LEWG 投票决定在 C++23 中合并网络 TS。

这一点，再加上没有具体的计划如何让执行器与并行算法一起工作，或者在“执行器世界”中如何处理`std::async()`的问题，大大削弱了在 [p0443](https://wg21.link/p0443) 中指定的执行器是 C++20 的一部分的情况，但截至目前，p0443 的一些版本仍在 C++20 的轨道上。

## 协程和全体

在周六的全体会议上，没有就推进协程以将其包含在 C++20 草案中达成共识。在随后的讨论中，有人表示，科纳冬季会议不太可能提供任何新的信息，将反对意见变为一致同意。

## 其他资源

*   【2018 年 6 月 ISO C++会议行程报告(核心语言)
*   [Red Hat 开发者博客上的其他 C++文章](https://developers.redhat.com/blog/category/c-plus-plus/)

*Last updated: January 9, 2019*