# JDK 的 Shenandoah GC 14，第 2 部分:并发根和类卸载

> 原文：<https://developers.redhat.com/blog/2020/03/09/shenandoah-gc-in-jdk-14-part-2-concurrent-roots-and-class-unloading>

这部关于 JDK 14 号的 Shenandoah GC 的迷你剧的第一部分讲述了[自我修复障碍](https://developers.redhat.com/blog/2020/03/04/shenandoah-gc-in-jdk-14-part-1-self-fixing-barriers/)。本文讨论并发根处理和并发类卸载，这两者都旨在通过将 GC 工作从暂停阶段转移到并发阶段来减少 GC 暂停时间。

## 并行根处理

一旦同步标记完成，Shenandoah 需要完成标记并准备撤离。虽然这是两个逻辑上独立的操作，但它们是在一个容易混淆的“最终标记”暂停下执行的

虽然在谢南多厄疏散本身是同时进行的，但仍有一些事情需要暂停。其中包括:

*   预疏散和更新非弱根(例如，线程堆栈和强 JNI 句柄)。
*   预疏散和清理弱根(例如，弦表和弱 JNI 处理)。
*   卸载类。

由于这项工作是在暂停期间完成的，因此会影响暂停时间。为了最小化这些暂停时间，我们希望同时执行这些任务中的大部分。这种方法对于任何大小不受限制的 GC 根都特别重要。

我们需要在暂停期间预清空和更新所有 GC 根的原因是为了确保强不变量。任何读取或存储到的对象都必须在 to-space 中。

这里有一个重要的警告:从 GC 根中加载对象不使用加载引用屏障。因此，应用程序必须看到对象的正确副本，我们必须在解除暂停阻塞之前执行撤离和更新。在这个问题陈述中有一个相对简单的解决方案:确保来自相关 GC 根的负载由一个负载引用屏障(LRB)保护，我们称之为“本地 LRB”，并将这些根的实际更新移到并发阶段。

然而，所谓的“弱”根是特殊的。在标记过程中，我们可能会确定某些 GC 根不再可达。这个问题的一个例子是弱 JNI 处理。一旦弱 JNI 句柄被声明为死的(在最终标记期间)，它就不应该被意外复活——例如，通过将对其假定为死的对象的引用插回到堆中。

因此，我们不仅必须预清空和更新可到达的弱根(像所有其他根一样)，我们还需要清理不可到达的弱根，这样应用程序就不可能触及和恢复它们。

将这种清理转移到并发阶段需要本机 LRB 做额外的工作，它检查弱根是否可达(如标记位图所示)。如果弱根不可达，本机 LRB 简单地返回 NULL，从而向 JVM 的其余部分假装句柄已经被清理。这个过程确保我们不会意外地使一个已经不可到达的对象再次变得可到达。

在伪代码中，原生 LRB 看起来像这样:

```
T native_LRB(T* addr) {
  T obj = *addr; // Load from GC root
  if (is_reachable(obj)) {
    return LRB(obj);
  } else {
    return NULL;
  }
}

```

## 并发类别卸载

在最终标记暂停期间的另一个大项目是*类卸载*，这对大量使用类加载器的应用程序很重要。这种情况通常出现在应用服务器和其他大型应用程序(例如 ide)中。然而，当使用匿名类(每个匿名类都有自己的类装入器)和 lambdas(类似于匿名类)时，类卸载也是相关的。

类卸载是一个复杂的过程。它需要代码来确定类(或者更确切地说，类加载器)是否可达。该检查已经在并行标记期间发生。当所有对象(包括类装入器)的可达性建立后，所有不可到达的类装入器及其类和辅助数据结构都需要被解除链接和清理。属于这些类的编译代码需要清理。

在很大程度上，Shenandoah 的实现建立在 ZGC 开发者在 JDK 13 中所做的工作之上。这种实现确实需要上述的本机屏障。除此之外，它还需要所谓的“非方法进入壁垒”。

通常，在暂停期间，我们需要预清空并更新所有编译方法中嵌入的所有引用。理想情况下，我们将只预清空/更新当前正在执行的方法中的引用(即堆栈上的框架可到达的引用)，同时处理其他方法。为了让这种方法工作，我们需要处理线程开始执行方法的场景。

nmethodbarrier 背后的思想是，无论何时调用一个方法，它们都会被执行。在执行被移交给方法之前，GC 屏障被调用来做某些事情。在 Shenandoah 中，这意味着扫描嵌入对象(常量)的方法代码，并清空和更新它们，以确保上面的强不变量。活动的 nmethods 在最后一个标记暂停时准备好，在并发阶段由 GC 线程解除，或者在 nmethods 即将执行时由 Java 线程解除。

并发根处理和并发类卸载的净优势是最终的标记暂停时间更短，从而改善了全局延迟，即使应用程序大量使用类加载器或 JNI 句柄。

*Last updated: June 29, 2020*