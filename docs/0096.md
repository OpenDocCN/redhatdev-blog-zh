# OpenJDK 16 中的 Shenandoah 垃圾收集:并发引用处理

> 原文：<https://developers.redhat.com/articles/2021/05/20/shenandoah-garbage-collection-openjdk-16-concurrent-reference-processing>

OpenJDK 中的 [Shenandoah 垃圾收集(GC)项目](https://openjdk.java.net/projects/shenandoah/)背后的主要动机是减少垃圾收集暂停时间。传统上，引用处理是 GC 暂停的主要原因之一。这种关系基本上是线性的:应用程序产生的引用越多，对垃圾收集暂停和延迟的影响就越大。这里的关键是“搅动”，或者说每个 GC 周期需要处理多少引用。具有永不消亡的引用对象的引用，或者与引用本身一起消亡的引用，都不是问题。

我自己过去曾建议过，如果你关心延迟，你最好不要搅动软的、弱的和虚幻的引用或终结。在本文中，我想展示为什么引用处理在过去会导致 [Java](/topics/enterprise-java) 垃圾收集暂停，以及我们如何通过在 JDK 16 中使引用处理并发来解决这个问题。

**TL；DR** :如果你的应用程序在软引用、弱引用或幻像引用或终结中颠簸，JDK 16 及其在 Shenandoah GC 中的并发引用处理可能会显著改善你的应用程序的延迟。

## 参考摘要

本文中的术语*引用*是指`java.lang.ref.Reference`类型的 Java 对象及其子类型`SoftReference`、`WeakReference`、`PhantomReference`和`FinalReference`(后面会详细介绍最后一个)。对象之间的常规引用也称为*强引用*。每个引用指向一个所指对象。各种引用类型的目的是能够引用一个对象，但不能阻止该对象被引用回收。回收遵循可达性规则，其大致规定如下(按可达性递减顺序):

*   一旦被引用对象不再被任何强引用访问，它就可以被回收。回收还受到其他启发的影响；例如，通常软引用不会被回收，除非存储器压力很高。这使得软引用适合于对内存敏感的(缓存)实现。这是一个相当糟糕的选择，但仍然是一个选择:当内存紧张时，GC 会清除软引用。
*   一旦被引用对象不再被任何强引用或软引用所访问，它就可以被回收。只要它没有被回收，引用对象仍然可以被访问，此时它再次变得强可达。
*   你可能不知道这个，因为它是 JDK 内参类型。用于实现`Object.finalize()`。任何实现了`finalize()`的对象都成为一个`FinalReference`的被指对象，并被注册到一个相应的`ReferenceQueue`中。一旦该对象不再能被强引用、软引用或弱引用访问，它就会被处理并调用它的`finalize()`方法。
*   一旦任何强引用、软引用、弱引用或最终引用都无法再到达该对象，就可以回收该对象；换句话说，当它完全不可及时。引用对象永远不能被访问。这样做是为了在被确定为不可到达之后，引用对象不会被意外复活。一旦确定了引用对象的可到达性，不可到达的引用对象就被清除(设置为空),并且它们对应的引用对象在各自的`ReferenceQueue`中排队，以供应用程序进一步处理。幻像引用通常用于管理资源，如本机内存或操作系统文件句柄，否则 GC 无法处理这些资源。

## 传统参考加工

在 JDK 16 之前的版本中，Shenandoah 发现和处理引用的方式严格遵循上一节中的可达性规则:

*   首先，我们确定并发标记期间所有强可达对象的可达性。一旦标记波前到达仍不具有标记的参照对象的参照对象(即，从其他地方不可强到达的对象)，它就在那里停止，并将该参照排入四个*发现队列*中的一个以供以后处理。每个引用类型都有一个发现队列。一种特殊的情况涉及软引用:GC 可以基于启发法(例如，内存压力和/或对象年龄)决定是否将软引用视为强引用。
*   接下来，一旦并发(强)标记完成，JVM 就停止应用程序并开始处理发现队列:
    1.  所有的`SoftReference`物体都被检查。如果引用对象不是强可达的(即，由并发标记来标记)，则它被清除，并且`SoftReference`被放入处理队列中。
    2.  所有的`WeakReference`物体都被检查。如果 referent 不是强可达的，那么它被清除，并且`WeakReference`被放入处理队列中。
    3.  所有的`FinalReference`物体都被检查。如果引用对象不是强可达的，那么`FinalReference`被放入处理队列，但是引用对象还没有被清除，因为稍后仍然需要它，以便 GC 可以调用它的`finalize()`方法。此外，现在发生了一些特殊的事情:从否则无法到达的所指对象开始，标记被恢复，并且从所指对象中找到的对象的子图被标记。这在下一步中很重要，以避免回收可从终结器到达的`PhantomReference`对象。这个额外的标记过程是有问题的，因为它是在 JVM 停止时发生的，并且理论上只受活动数据集大小的限制。换句话说，我们可能要花很多时间来标记终结子图。
    4.  所有的`PhantomReference`物体都被检查。如果引用对象是不可达的(既不是强的，也不是来自终结器)，那么引用对象被清除，并且`PhantomReference`被放入处理队列中。
*   最后，处理队列被添加到一个 Java 链表中，用于进一步的`ReferenceQueue`处理。

从这些步骤可以得出，引用处理对 GC 暂停时间的贡献基本上与*处理的引用数+新标记子图的大小*成正比。

为了解决引用处理的暂停时间问题，我们需要 GC 同时执行。引用处理的任务可以分为两个子任务:引用对象的并发标记，包括它们各自的子图，以及引用的并发处理和清除。这两个子任务在传统实现中纠缠在一起，所以让我们看看如何解开它们。

### 并发参考标记

通过对传统实现的进一步研究，我们发现我们可以简化可达性模型。我们实际上没有五个可达性级别(强、软、弱、最终、幻影)，而是只有两个。让我们从另一个角度来看一下对推荐人进行分类的标准:

*   当所指对象不是强可达的，并且我们满足某个启发时，对象被清除并排队。本质上，我们可以在并发标记之前或期间决定是将`SoftReference`视为强引用还是弱引用。
*   当所指对象不是强可及时，对象被清除并排队。
*   当所指对象不是强可及时，对象被排队。
*   当引用对象不是强可达的并且不能从任何`FinalReference`到达时，s 被清除并排队。

换句话说，我们的两个相关可达性水平是*强可达*和*最终可达*。

传统实现通过在以下步骤中进行标记来确定可达性:

1.  在并发标记期间，我们建立所有强可达对象的集合。
2.  我们处理所有只需要此可达性级别的引用—软引用、弱引用和最终引用。
3.  我们继续从终结标记。
4.  我们处理剩余的虚拟引用，它们也需要这些新信息。

我们能同时确定强可达性和可终结可达性吗？我们当然可以。但是我们需要稍微扩展一下我们的标记位图:我们现在需要两位来表示所有可能的状态:强可达、最终可达和不可达(以及内部使用的第四种状态)，而不是每个对象使用一位(标记和未标记)。有了这些信息，我们现在可以同时标记所有活动对象，并确定强可达性和可终结可达性:

1.  从具有正常强波前的根部开始标记。
2.  一旦一个强波前遇到一个`SoftReference`，决定(基于启发式)它是应该被当作一个强参考还是弱参考。如果软引用应被视为强引用，通常标记整个引用对象(将其子图标记为强引用)，否则在那里停止波前，并将软引用排入发现队列。
3.  当一个强波前遇到一个`WeakReference`或`PhantomReference`时，在那里停止该波前，并将该参考放入发现队列中。
4.  一旦一个强波前遇到一个`FinalReference`，将该`FinalReference`标记为强，并切换到最终可确定的波前来标记参考物。从此处可访问的所有对象现在都将被标记为可终结的。
5.  当强波前遇到已经标记为可终结的对象时，将该对象及其子图升级为强。

现在我们已经同时标记了所有可达对象，并确定了它们是强可达的还是最终可达的。我们还将所有引用对象放入我们发现的队列中，以便进一步处理。这就解决了问题的前半部分。我们仍然需要清除不可到达的引用对象，并对引用对象进行排队。

### 并行参考处理

我们在标记过程中同时建立了可达性。这在最后标记的暂停中完成，我们也在那个暂停中为撤离做准备。并发引用处理发生在并发撤离阶段的开始。我们需要做两件事:

1.  扫描发现的队列并清除所有不可到达的引用对象。
2.  将“不可到达”的引用对象排入处理队列，以便在 Java 端进一步处理。

这些任务听起来很简单:我们同时扫描发现的队列，检查每个引用对象，并查看引用对象是否可达。我们遵循前面提到的可达性规则:为了可达，软引用、弱引用和最终引用必须是强可达的，而幻象引用必须是强可达的或最终可达的。如果引用不可达，则清除引用对象并将引用放入处理队列中。

但是等等:如果 Java 程序试图在我们清除它之前访问 referent 怎么办？它仍然会看到我们认为无法触及的所指物，并因此复活它。这违反了规范，会导致各种问题，甚至 JVM 崩溃，因为 GC 随后会回收或覆盖该对象，Java 程序会以一个悬空指针结束。

这个问题的解决方案是我们在`Reference.get()`中插入一个特殊的屏障。我们已经有了一个 LRB，因为它是一个参考载荷:

```
// Pseudocode of Reference.get() intrinsic
T Reference_get() {
  T ref = this.referent;
  return lrb(ref);
}
Let's return null when the referent is unreachable:

// Pseudocode of Reference.get() for concurrent reference processing
T Reference_get() {
  T ref = this.referent;
  if (isUnreachable(ref) {
    return null;
  }
  return lrb(ref);
}
```

*瞧！*现在，每当我们试图访问一个不可及的引用对象时，我们总是返回`null`，Java 应用程序永远不会意外地恢复一个对象。

## 理论够了，给我看看数字

实际上，并发垃圾收集有多糟糕？

让我们看一个适度使用引用和终结的工作负载，它运行在 JDK 11 下。`-Xlog:gc+stats`选项给了我们一些统计数据:

```
Pause Final Mark (N)           =    0,278 s (a =     3812 us) (n =    73) (lvls, us =      893,     2891,     3535,     4414,     7707)
  Finish Queues                =    0,020 s (a =      273 us) (n =    73) (lvls, us =       94,      123,      137,      227,     4426)
  Weak References              =    0,214 s (a =     2929 us) (n =    73) (lvls, us =      158,     2109,     2695,     3555,     6072)
    Process                    =    0,213 s (a =     2924 us) (n =    73) (lvls, us =      154,     2109,     2695,     3555,     6067)
```

这表明，在平均 3.8 毫秒的最终标记暂停中，GC 在弱引用处理上花费了 2.9 毫秒，在最坏的情况下，甚至在 7.7 毫秒中花费了 4.4 毫秒

让我们看看 JDK 16 的相同代码:

```
Pause Final Mark (G)           =    0,208 s (a =     2044 us) (n =   102) (lvls, us =      688,      820,      914,     1562,    36975)
Pause Final Mark (N)           =    0,089 s (a =      870 us) (n =   102) (lvls, us =      500,      625,      705,      764,     4489)
  Finish Queues                =    0,034 s (a =      329 us) (n =   102) (lvls, us =      107,      125,      174,      246,     4072)
  Update Region States         =    0,004 s (a =       38 us) (n =   102) (lvls, us =       26,       34,       38,       41,       52)
  Manage GC/TLABs              =    0,001 s (a =       13 us) (n =   102) (lvls, us =        9,       13,       13,       14,       22)
  Choose Collection Set        =    0,019 s (a =      183 us) (n =   102) (lvls, us =       97,      156,      188,      203,      323)
  Rebuild Free Set             =    0,002 s (a =       23 us) (n =   102) (lvls, us =       13,       20,       23,       25,       29)
  Initial Evacuation           =    0,028 s (a =      274 us) (n =   102) (lvls, us =      133,      207,      227,      260,     3264)
    E:                  =    0,247 s (a =     2422 us) (n =   102) (lvls, us =      799,     1875,     2031,     2090,    39583)
    E: Thread Roots            =    0,247 s (a =     2422 us) (n =   102) (lvls, us =      799,     1875,     2031,     2090,    39583)
Concurrent Weak References     =    0,967 s (a =     9479 us) (n =   102) (lvls, us =      152,     4824,     9473,    11914,    39231)
  Process                      =    0,966 s (a =     9470 us) (n =   102) (lvls, us =      148,     4805,     9453,    11914,    39215)
[
```

引用处理完全摆脱了最终标记暂停，暂停时间减少到 0.9 毫秒。引用处理现在单独列在“并发弱引用”下，平均耗时 9.5 毫秒，但我们并不太在意，因为它不会阻止应用程序运行。

这些数字来自相对适中的工作量。我们已经处理了一个有数百万弱引用和终结的客户工作负载，正如所预料的那样，那里的影响要显著得多。

## 结论

如果您正在使用弱引用、软引用缓存、终结器或幻像引用进行资源清理，并且您关心垃圾收集暂停和延迟，您可能希望升级到 JDK 16 并尝试一下 Shenandoah GC。

关于 Java 的更多信息，请参考相关的[红帽开发者主题页面](/topics/enterprise-java)。

*Last updated: April 22, 2022*