# 调试和检查编译器优化的二进制文件时可能出现的问题

> 原文：<https://developers.redhat.com/blog/2020/03/13/possible-issues-with-debugging-and-inspecting-compiler-optimized-binaries>

开发人员认为他们的程序是按照原始源代码编写的运行的一系列操作。然而，程序源代码只是计算的规范。编译器分析源代码，并确定对指定操作的更改是否会产生相同的可见结果，但会更有效。它将消除最终不可见的操作，并重新安排操作以提取更多并行性并隐藏延迟。当通过像 GDB 和 SystemTap 这样的工具检查优化的二进制代码的执行时，原始程序的源代码和实际运行的优化的二进制代码之间的这些差异可能是可见的。

为了帮助调试和检测二进制文件，编译器会生成调试信息，以便在源代码和可执行二进制文件之间进行映射。调试信息包括每条机器指令与源代码的哪一行相关联，变量位于何处，以及如何展开堆栈以获得函数调用的回溯。但是，即使编译器生成了这些信息，在检测编译器优化的二进制文件时，也可能会观察到一些非直观的效果:

*   代码中缺少预期的探测点。
*   变量值在某些位置可能不可用。
*   一个变量在一个位置可能有多个值。
*   多个变量在一个位置混合了新旧值。
*   多个完全不同的同名变量存在于一个位置。

这些意想不到的行为是鼓励开发人员使用`-Og`而不是用`-O2`或`-O3`启用编译器优化的部分原因。然而，在有些情况下，开发人员可能无法选择使用更易于调试的选项来重新编译代码。在调查一个行为不端的程序时，理解这些情况发生的原因可能会节省您的时间并减少您的挫折感。让我们来看看。

## 因为线被消除而丢失探测点

特定源代码行的二进制代码可能会被编译器删除，因为它对后面的结果没有影响。当编译器对该函数的数据和控制流分析确定该行上的代码位于可以执行的控制流路径上，但计算出的值从未被使用时，可能会发生这种移除。将指令映射回源代码的调试信息将没有那些被删除的行的条目。GDB 和 SystemTap 将无法在那些精确的源代码行检查程序的状态，因为它们不再存在于二进制文件中。

当一个函数在多个地方内联时，这些意外丢失的源代码行可能会变得更成问题:内联函数的一些实例优化掉了一行，但其他内联版本保留了同一行。这种情况可能会导致错过应该检测的路径。如果特定的行不可用，SystemTap 确实有逻辑将探测点放在丢失的行附近，但是在生成的代码中包含该行的实例的情况下，SystemTap 可能会丢失该行被删除的其他实例。

[DWARF](https://en.wikipedia.org/wiki/DWARF) 调试信息规范包括一个标记基本块开始的标志，可以帮助识别每个基本块附近的其他行。然而，在迄今为止检查过的生成代码中，GCC 或 Clang 编译器似乎从未设置过这个标志。

## 变量值可能不存在于代码中的某一点

编译器试图提高效率，将值存储在访问成本最低的地方。在现代处理器上，可以以最小的延迟来访问寄存器。然而，在大多数处理器上，只有有限数量的寄存器来存储值，这使得它们成为稀缺资源。

编译器寄存器的分配代码试图使用相同的寄存器在不同的时间保存不同的变量来最大化寄存器的利用率。编译器可以确定在二进制中的某一点不再使用变量值，并重新使用寄存器来保存另一个变量，一旦写入新变量，旧的变量值就会丢失。因此，在机器码的特定位置，特定变量可能没有任何可用的值。

## 特定变量的多个值可能存在于一个探测点

开发人员可能会重用单个变量来保存函数中不同位置上彼此不相关的值。编译器可能会对二进制文件中与该变量相关的操作进行重新排序，以便这些多个值同时有效，从而利用处理器并行执行指令的能力，或者提前移动操作，以免延迟后面的相关操作。

当一个函数的局部变量在另一个函数中多次内联时，可能会出现这种效果。内联函数的多个实例的指令被重新排序，使得来自内联函数的局部变量的不同实例同时有效。这种效应也可能发生在循环展开中，此时一个循环的多次迭代被安排在一起。迭代`i`、`i` +1、`i` +2 和`i` +3 的局部变量`a`可能在二进制文件的同一点都有值。对于主动矢量化，这个问题可能会变得更加普遍。

## 在特定位置，多个变量的值可能不一致

如前所述，编译器可能会交错或改变操作的顺序。下面是一个简单的例子，我们可能希望在计算`d`的行上进行探测，期望得到`a`的当前值:

```
a = b + c /* source line 1 */
d = e * f /* source line 2 */
g = d + a /* source line 3 */
```

然而，编译器可能会像下面的代码一样对操作进行重新排序，以便在计算`d`和使用它来计算`g`之间提供更多的时间。如果程序员在运行第二行后立即检查值，那么`d`的值是可用的，但是`a`的值还没有被计算(不像上面的原始源代码):

```
d = e * f /* source line 2 */
a = b + c /* source line 1 */
g = d + a /* source line 3 */
```

## 完全不同的同名变量

可执行文件中的某个位置可能有多个同名变量。你见过多少次变量`i`用作循环迭代变量，`p`用作指针？例如，用作函数调用参数的变量可能与内联函数的参数同名，或者内联函数可能具有与调用函数相同的局部变量名。这种设置可能会导致混淆，不知道您正在检查哪个函数的变量`i`或`p`。

## 调试很难

[Brian Kernighan](http://en.wikipedia.org/wiki/Brian_Kernighan) 在*第二版第二章*中写道:

> 调试比一开始写代码要难两倍。因此，如果你尽可能聪明地编写代码，从定义上来说，你没有足够的聪明去调试它。

现在，有了聪明的编译器，调试会更加困难！让代码尽可能简单，并考虑使用这些[技术让代码更加透明和明显](https://developers.redhat.com/blog/2018/05/14/making-the-operation-of-code-more-transparent-and-obvious/)。

*Last updated: June 29, 2020*