# JDK 13 中的 Shenandoah GC，第 2 部分:消除前向指针词

> 原文:[https://developers . red hat . com/blog/2019/06/28/Shenandoah-GC-in-JDK-13-part-2-eliminating-the-forward-pointer-word](https://developers.redhat.com/blog/2019/06/28/shenandoah-gc-in-jdk-13-part-2-eliminating-the-forward-pointer-word)

在这一系列文章中，我将讨论即将在 [JDK 13](https://developers.redhat.com/products/openjdk/overview/) 举行的 [Shenandoah GC](https://developers.redhat.com/videos/youtube/N0JTvyCxiv8/) 的新进展。在[第一部分](https://developers.redhat.com/blog/?p=602377)中，我查看了谢南多厄的障碍模型中加载参考障碍的开关以及这意味着什么。

我想在这里讨论的变化解决了另一个常见的——也许是最常见的——关于 Shenandoah GC 的问题:每个对象需要一个额外的单词。许多人认为这是 Shenandoah 的核心要求，但实际上不是，正如您将在下面看到的。

让我们首先来看看 Hotspot JVM 中一个对象的常见对象布局:

| 0: | [标记词] |
| 8: | [类别词] |
| 16: | [字段 1 ] |
| 24: | [字段 2 ] |
| 32: | [字段 3 ] |

这里的每个部分都标记了一个*堆字*。在 64 位架构上是 64 位，在 32 位架构上是 32 位。

第一个字就是所谓的*标记字*，或者对象的头。它有多种用途。例如，它可以保存一个对象的散列码；它有 3 位用于各种锁定状态；一些 GC 用它来跟踪对象年龄和标记状态；并且可以用指向“位移”标记的指针、指向“膨胀”锁的指针或者在 GC 期间的转发指针来“覆盖”它。

第二个字保留给 *klass 指针*。这只是一个指向代表对象类的热点内部数据结构的指针。

数组旁边会有一个额外的字来存储数组长度。接下来是对象的实际负载，即字段和数组元素。

在启用了 Shenandoah 的情况下运行时，布局应该是这样的:

| -8: | [前进指针] |
| 0: | [标记词] |
| 8: | [类别词] |
| 16: | [字段 1 ] |
| 24: | [字段 2 ] |
| 32: | [字段 3 ] |

前进指针用于 Shenandoah 的同步疏散协议:

*   正常情况下，它指向自身->对象尚未被疏散。
*   当清空时(通过 GC 或通过写屏障)，我们首先复制对象，然后使用原子比较和交换安装指向该副本的新转发指针，可能产生指向违规副本的指针。只有一份赢。
*   现在，只需通过读取这个转发指针就可以找到要读取或写入的规范副本。

这种协议的优点是简单而廉价。这里廉价方面很重要，因为，请记住，Shenandoah 需要为每一次读或写解析 forwardee，即使是简单的读或写。而且，使用这种协议，它的读屏障将是一条指令:

```
mov %rax, (%rax, -8)
```

这是最简单不过的了。

缺点显然是需要更多内存。在最坏的情况下，对于没有任何有效载荷的对象，对于一个本来是两个单词的对象来说，多了一个单词。多了 50%。对于更真实的对象大小分布，你仍然会有 5%-10%的额外开销，YMMV。这也会导致性能下降:分配相同数量的对象会比没有这种开销时更快达到上限——更频繁地引发 GCs 从而降低吞吐量。

如果你已经仔细阅读了，你会注意到一些 GC 也使用/覆盖标记词来携带转发指针。那么，为什么不在谢南多厄做同样的事情呢？答案是(或者曾经是)，读取转发指针需要更多的工作。我们需要以某种方式区分真正的标记字和转发指针。这是通过设置标记字中的最低两位来实现的。这些通常用作锁定位，但组合 0b11 不是合法的锁定位组合。换句话说，当它们被设置时，最低位被屏蔽为 0 的标记字将被解释为转发指针。标记字的这种解码比上述转发指针的简单读取要复杂得多。事实上，[前一段时间](https://twitter.com/rkennke/status/1076532471880212481)我做了一个原型，阅读障碍的额外成本令人望而却步，不值得节省。

所有这些都随着最近到达的负载[参考障碍](https://rkennke.wordpress.com/2019/05/15/shenandoah-gc-in-jdk13-part-i-load-reference-barriers/)而改变:

*   我们不再需要读屏障，尤其是在(非常频繁的)原始读上。
*   负载参考障碍是有条件的，这意味着它们的慢路径(实际分辨率)仅在 1 时被激活。GC 处于活动状态，2。有问题的对象在收集组中。这是相当罕见的。将它与之前一直存在的阅读障碍进行比较。
*   我们不再允许任何来自太空的拷贝。强不变量保证了我们只能读写空间副本。

两个后果如下。from-space 副本实际上不做任何事情，我们可以将该空间用于转发指针，而不是为它保留一个额外的字。我们基本上可以将来自太空的拷贝的全部内容销毁，并将转发指针放在任何地方。我们只需要能够区分“未转发”(其他内容我们不关心)和“转发”(剩下的就是转发指针)。

这也意味着负载参考栅的实际中间和慢速路径并不那么热，我们可以轻松地在那里进行一点解码。它相当于(在伪代码中):

```
oop decode_forwarding(oop obj) {
  mark m = obj->load_mark();
  if ((m & 0b11) == 0b11) {
    return (oop) (m & ~0b11);
  } else {
    return obj;
  }
}
```

虽然这看起来明显比转发指针的简单加载更复杂，但它基本上仍然是免费的午餐，因为它只在不太热的加载引用屏障的中间路径执行。这样，新的对象布局将是:

| 0: | [标记字(或前进指针)] |
| 8: | [类词] |
| 16: | [字段 1] |
| 24: | [字段 2] |
| 32: | [字段 3] |

这种方法有几个优点:

*   显然，它通过去掉额外的单词减少了 Shenandoah 的内存占用。
*   不太明显的是，它导致了吞吐量的增加:我们现在可以在触发 GC 之前分配更多的对象，从而减少了实际 GC 所花费的周期。
*   对象被更紧密地打包，这导致了 CPU 缓存压力的改善。
*   同样，所需的 GC 接口更简单:当我们需要分配路径的特殊实现(保留和初始化额外的字)时，我们现在可以使用与任何其他 GC 相同的分配代码。

为了让您对吞吐量的提高有所了解，请注意，我尝试的所有 GC 敏感基准测试都显示了 10%到 15%之间的提高。其他人受益较少或者根本没有受益，但是对于根本不进行任何 GC 的基准测试来说，这并不奇怪。

然而，重要的是要注意，额外的解码成本实际上不会出现在任何地方；基本可以忽略不计。它可能会在大量疏散工作负载时出现，但大多数应用程序不会疏散那么多，而且大多数工作都是由 GC 线程完成的，这使得中途解码足够便宜。

这个实现最近已经被推送到 T2 的谢南多厄/JDK 的库。我们目前正在抖出最后一个已知的错误，然后它将准备好进入 JDK 13 仓库。该计划是最终将它反向移植到谢南多厄的 JDK 11 和 JDK 8 反向移植库，并从那里进入 rpm。如果你不想等待，你已经可以拥有它了:看看[的 Shenandoah GC Wiki](https://wiki.openjdk.java.net/display/shenandoah/Main) 。

### 阅读更多

[JDK 谢南多厄 GC 13，第 1 部分:荷载参考屏障](https://developers.redhat.com/blog/?p=602377)

[JDK 2013 年 Shenandoah GC，第 3 部分:架构和操作系统](https://developers.redhat.com/blog/?p=606497)

*Last updated: July 2, 2019*