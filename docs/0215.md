# 用 GNU 汇编程序(GAS)编写可移植汇编程序的技巧

> 原文:[https://developers . red hat . com/blog/2021/02/26/tips-for-writing-portable-assembler-with-GNU-assembler-gas](https://developers.redhat.com/blog/2021/02/26/tips-for-writing-portable-assembler-with-gnu-assembler-gas)

当您熟悉目标体系结构的指令集时，编写汇编代码很简单，但是如果您需要为多种体系结构编写代码，该怎么办呢？例如，您可能想测试某个特定的汇编程序功能是否可用，或者生成一个目标文件供另一个工具使用。编写可以在多种架构上工作的汇编源代码并不是那么简单。

本文描述了使用汇编代码时遇到的常见问题类型，以及克服这些问题的技术。您将学习如何解决汇编代码中的注释、数据、符号、指令和节的问题。为了让您入门，可移植汇编器演示源文件提供了许多 GNU 汇编器(GAS)汇编代码的例子。我将在本文中使用几个例子。

## 注释的问题

没有与体系结构无关的方式来创建带前缀的行注释。因此，

```
  # This is a comment

```

可能成功也可能失败，这取决于目标。(在某些体系结构中，散列字符实际上是指令集的一部分，分号和冒号字符也是如此。)

相反，安全的方法是使用类似 C 语言的注释:

```
  /* This is a comment. */

```

但是请记住，这些注释不能嵌套:

```
  /* This is /* not a */ valid comment. */

```

## 数据问题

单个数据项的大小，如整数、指针、浮点等等，在不同的体系结构中是不同的。举以下例子:

```
  .data
  .word 0x12345678

```

如果一个字的长度少于 4 个字节，这段代码将无法在机器上汇编。(幸运的是，`.data`指令是通用的。)

插入特定整数值的更可靠的方法是使用`.dc.<letter>`指令，其中`<letter>`是字节的`b`，`w`是 16 位值，`l`是 32 位值。这里有一个例子:

```
  .data
  .dc.b 0x78
  .dc.w 0x5678
  .dc.l 0x12345678

```

这个汇编代码适用于所有目标，不管它们的字长如何。

### 插入 64 位整数值

奇怪的是，64 位值的指令并不遵循相同的命名方案。相反，要使用的指令是`.quad`:

```
  .quad 0x1234567890abcdef
```

### endian ness

所有值都以目标的 endian 格式存储，这通常是正确的方法。但是，当需要固定顺序时，可以指定多个单字节值:

```
  .data
  .dc.b 0x78, 0x56, 0x34, 0x12

```

即使在大端体系结构上，这段代码也会产生字节的小端排序。但是，您不能在字节大小大于 8 位的目标上创建多字节位模式(例如，德州仪器的 TIC54x。)外部援助是处理这种特殊情况的唯一方法:

```
  .data
  .ifdef big_bytes
  .dc.b 0x5678, 0x1234
  .else
  .dc.b 0x78, 0x56, 0x34, 0x12
  .endif

```

如果符号`big_bytes`是为 16 位字节架构定义的，则该解决方案有效，否则无效。(符号可以用`--defsym <name>=<value>`在 GAS 命令行上定义。)

### 对齐要求

存储数据值的指令的另一个问题是它们可能有对齐要求。例如:

```
  .data
  .dc.b 0xff
  .dc.l 0x12345678

```

这个例子无法为 SH 目标汇编，因为`0x12345678`中的 4 个字节没有存储在 4 字节对齐的边界上。您可以使用对齐指令来解决这个问题，但是要小心使用`.align`，它具有特定于目标的语义。相反，使用`.balign`或`.p2align`指令:

```
.data
  .dc.b 0xff
  .balign 4
  .dc.l 0x12345678

```

注意，这段代码在`0xff`字节和`0x12345678`字之间引入了一个间隙。

### 固定值

GAS 支持对符号和常数进行简单的算术和逻辑运算。对于大多数指令，结果必须是固定值。这里有一个例子:

```
  .dc.b (val & 0xff), (val >> 8) & 0xff

```

如果符号`val`在计算指令时有一个定义的值，这个代码就可以工作。

### 存储字符串

字符串很容易存储，但是要注意,`.ascii`指令不存储终止的 NUL 字节。对于类似 C 的字符串，请使用`.asciz` 指令:

```
  .ascii "this string has no NUL byte at the end"
  .asciz "this string does"

```

## 符号的问题

标签和符号有多种定义方式，所有方式都适用于大多数目标:

```
  val = 0x1234
  .equiv here, .
  .equiv there, here + 4
  this_is_a_label:

```

然而，为了与 HPPA 汇编程序相比较，有必要在一行的第一列开始一个标签的名称。另外，通过扩展，如果没有定义标签，任何一行的第一列都需要包含一个空白字符。

如果一个符号或标签包含一个地址，那么使用`.dc.a`指令将它插入到代码中是最安全的，就像这样:

```
  .dc.a this_is_a_label

```

您可以对地址执行简单的加法或减法运算，但通常不支持更复杂的运算。计算两个标签之间的差异通常只在它们被定义在同一个部分时才有效，有时甚至没有:

```
  .dc.a label1 - 2      /* This will work. */
  .dc.a label1 - label2 /* This might not work. */

```

## 指令的问题

通常，指令是特定于各个体系结构的。因此，您不能编写包含代码的通用汇编源文件。然而，从 GAS 2.35 开始，有了一个新的伪操作指令(`.nop`)，它可以在任何目标上生成空操作指令:

```
  .text
  .nop /* This is a real instruction. */

```

## 部分的问题

所有架构都接受段名`.text`、`.data`和`.bss`。旧的 AOUT 文件格式只支持这些名称。更现代的格式如可移植可执行文件(PE)和可执行可链接格式(ELF)支持任意的节名。在定义新的部分时，要注意 ELF 目标的`.section`指令比 PE 版本接受更多的参数:

```
  .section name                  /* See note 1\. */
  .section name, "flags"         /* See note 2\. */
  .section name, "flags", %type  /* See note 3\. */

```

注意事项:

1.  这种形式在区段标志是强制的目标上失败。
2.  这种形式对基于 PE 和基于 ELF 的目标都有效，尽管标志是不同的。
3.  这个形态只对基于 ELF 的目标有效。注意使用了 *%* 字符，而不是 *@* 字符。

## 结论

本文讨论了编写可移植汇编代码的常见问题，并提供了解决方案和示例。总之，编写可移植汇编程序很难，最好保持简单，持久性是关键。

*Last updated: October 7, 2022*