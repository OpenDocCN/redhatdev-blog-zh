# GCC 中的堆栈冲突缓解:Why -fstack-check 不是答案

> 原文：<https://developers.redhat.com/blog/2019/04/30/stack-clash-mitigation-in-gcc-why-fstack-check-is-not-the-answer>

在我们关于堆栈冲突的前一篇文章中，我们介绍了 T2 堆栈冲突漏洞的基础知识。总而言之，攻击者首先使用各种方法将堆和栈放在一起。然后使用大量堆栈分配来“跳过堆栈保护”后续的堆栈存储可能会修改堆中的对象，反之亦然。反过来，攻击者可以利用这一点来控制应用程序。

GCC 有一个能力(`-fstack-check`)，看起来很有希望减轻堆叠冲突攻击。本文将介绍`-fstack-check`如何工作，以及为什么它不足以缓解堆栈冲突攻击。

## 背景

GCC 有一个标志`-fstack-check`，用于探测堆栈分配。仔细探测堆栈分配可以防止堆栈和堆发生冲突，从而防止堆栈冲突攻击。那么，我们是否可以用`-fstack-check`来防止栈和堆发生碰撞呢？在确定是否适合堆栈冲突缓解之前，我们必须理解`-fstack-check`的设计/实现决策。

Ada 程序使`-fstack-check`能够检测不同线程之间的无限递归和堆栈溢出。检测到任何一种情况都会导致程序报告错误(通常通过用户空间信号处理程序)。

要求程序在出错时运行信号处理程序意味着总是有足够的堆栈可供信号处理程序执行。因此，`-fstack-check`必须探测当前函数的实际堆栈需求，以确保堆栈空间可用于信号处理器。

此外，假设整个程序是用`-fstack-check`编译的(如果您正在编写 Ada 代码，这是一个合理的假设)。

这两种属性的结合是至关重要的。因为每个函数都会探测超出其当前需求的 1-3 页，所以任何后续调用的函数在探测时都会跳过前 1-3 页。例如，考虑以下代码:

```
extern void bar (char *);

void
foo(void)
{
    char z[8192];
    bar (z);
}
```

用`-O2 -fstack-check`编译的结果为:

```
subq $12328, %rsp
 orq $0, 4104(%rsp)
 orq $0, 8(%rsp)
 orq $0, (%rsp)
 addq $4128, %rsp
```

第一条指令分配了 12328 字节的堆栈空间(同样，比它需要的要多，所以总是有足够的堆栈来运行用户空间信号处理程序)。在这一点上，我们已经失败了，因为该分配可能会跳过堆栈保护，后续的存储可能会写入堆中。探测器不会触及每个分配的页面。最后，您会注意到 orq 指令(探测器)写的地址超出了当前分配的堆栈。这给 Valgrind 等关键工具带来了严重的问题。

## 对于混合环境，使用-fstack-check 是不够的

在 Ada 世界之外，我们必须假设一个混合环境。最常见的场景是让操作系统供应商提供的密钥库(例如 glibc)与 ISV 或客户提供的用户空间代码进行交互。

在这种情况下，操作系统供应商可能已经使用堆栈检查编译了系统库，但是操作系统供应商无法控制 ISV 或客户是否使用堆栈检查编译他们的代码。让我们考虑一下在这种情况下会发生什么。

首先，让我们假设客户代码没有任何大的堆栈分配(也许这就是为什么他们在没有`-fstack-check`的情况下编译)。但是，客户代码存在内存泄漏。假设客户代码调用了一个具有大堆栈的 glibc 例程，并且 glibc 是用`-fstack-check`编译的。

这似乎是一个安全的组合，但它不是。

接下来，利用内存泄漏使堆栈和堆彼此靠近(可能在一个页面内)。然后调用一个大栈的 glibc 例程。如果 glibc 例程是用`-fstack-check`编译的，那么它将跳过探测前 1-3 页(由于`-fstack-check`的设计决策/假设)。堆栈指针现在会指向堆，存储到堆栈实际上会修改堆。堆栈和堆发生了冲突，现在有一个合理的机会，攻击者可以建立一个漏洞，以获得对程序的完全控制。

## -fstack-check 的更多问题

在一些目标上，当前的`-fstack-check`实现一次分配所有的堆栈空间，然后在刚刚分配的堆栈中以页面间隔进行探测。那么，如果程序安装了一个信号处理程序，并在分配堆栈空间和探测页面之间接收到一个异步信号，会发生什么呢？

在这种情况下，堆栈指针可能会越过防护指向堆。信号到达后，内核将控制权转移给注册的信号处理程序。然后，该信号处理程序在其堆栈指向堆时运行。因此，攻击者已经与堆栈和堆发生了冲突，他们很有可能获得对程序的控制权。

为了利用这个场景，信号传递必须发生在正确的点上(在栈分配之后，探测之前)。这进一步说明了保护系统免受堆栈冲突式攻击所需的对细节的关注。

那么我们该怎么办呢？请继续关注未来文章中的更多细节。

*Last updated: April 26, 2019*