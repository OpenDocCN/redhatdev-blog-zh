# C 和 C++别名的利弊，第 1 部分

> 原文：<https://developers.redhat.com/blog/2020/06/02/the-joys-and-perils-of-c-and-c-aliasing-part-1>

在 C、C++和其他一些编程语言中，术语*别名*指的是两个不同的表达式或符号引用同一个对象的情况。当引用以不同的方式访问该对象时——读取和存储——这些*混合访问*发生的顺序会有后果。首先存储的值预计将由后续访问读取。在许多情况下，别名是无害的:使用两个相同类型的指针来读取甚至写入同一个对象是常见的、安全的，并且通常效率最高。但是在某些情况下，对混合访问使用别名符号就不那么好了，会对代码的正确性或效率产生负面影响。

尽管有很多关于这个主题的文章，但大多数都倾向于关注标准中概述的规则和要求(例如*严格别名*规则)。在本文中，我将重点关注 C 和 C++语言限制的细节、它们的挑战和缺陷，以及演示这些限制在优化代码中的有益效果的示例。在第 2 部分中，我将介绍别名的免除，这可以帮助您或多或少地安全避开这些限制。我还考虑了别名和混合访问的一些常见缺陷，以及这些缺陷可能导致的实际问题。

## 关于示例

我用许多小的编码例子来说明我的主要观点。代码是有意简化的，并不意味着除了说明材料之外是有用的。此外，虽然优化是本文的主题，但在大多数情况下，优化代码示例的价值可以忽略不计，除非您是在连续执行许多代码。当这种代码出现在循环中时，通常会出现这种情况——特别是(但不仅仅是)可能适合矢量化的循环。我把这些例子扩展到它们更现实的“loopy”等价物，作为对感兴趣的读者的练习。此外，在整篇文章中，我包含了到我在[编译器浏览器](https://godbolt.org)上的例子的链接，这样您就可以看到一些流行的编译器是如何处理它们的。我鼓励您使用该站点来试验这些示例。我还想借此机会感谢网站的作者提供了非常有用的工具和服务。

一些例子说明了无效代码对优化结果的影响。需要强调的是，无效代码会导致整个程序的不确定行为。在小例子中看到的效果在更现实的程序中可能会有所不同。在更复杂的情况下，这些影响可能被编译器通过程序、翻译单元或函数跟踪控制流或数据流的有限能力所掩盖。效果还可能取决于代码中使用的操作数的常数值或取值范围，所有这些通常取决于优化选项、目标体系结构、特定编译器及其版本等因素。

## C 和 C++中的对象和类型

对象模型和类型系统掌握了 C 和 C++语言的一些最基本的原则。两种语言都依赖于*对象标识*:每个命名对象都由它的名字唯一地指定，没有其他标识符表示同一个对象。因为所有对象必须彼此不同，并且因为 null 是不指向任何对象的有效指针，所以没有两个对象地址可以彼此相等或指向 null。(值得注意的例外是第一个子对象的地址与其封闭对象的地址相等。也有可能一个指针刚好经过一个对象的末尾，与一个不相关的对象比较，结果等于 1，而这个对象恰好存储在那个位置，但这是偶然的，无法保证。)

### 通过兼容类型访问

不管它们有没有名字，所有的对象都有一个类型，它们的值只能在该类型中进行有意义的解释。例如，将类型为`int`的对象解释为`float`是没有意义的，反之亦然。对象值必须从一种类型转换为另一种类型(通常通过强制转换)才能被重新解释。但是对象本身只能在给定的类型内被访问，也就是说，存储或读取它们的值。对于有名称的声明对象，类型只是用于声明它的类型。对于一个动态分配的对象，类型(称为*有效类型*)是对象最后一次存储的类型。

**注意**:*相同类型*的要求并不完全准确，因为它没有抓住一个重要的微妙之处:相同基础整数类型的有符号和无符号形式被认为是相同的，相同基础类型的不同限定形式也被认为是相同的。但这些都是次要的细节。

### 尺寸的概念

与类型概念相关的是大小的概念。只能在对象大小限定的范围内访问对象，包括成员子对象和数组元素。在标准 C 和 C++中，每个对象和类型的大小都是非零的，但是一些编译器扩展允许这种保证有例外。在大多数情况下，大小由对象的类型决定。然而，单独调用这个约束是有用的，因为在访问聚集(指结构，特别是数组)时很容易违反它。

非正式地说，C 和 C++编程中的术语*别名*通常是指违反我刚刚介绍的类型规则。通常，别名意味着使用不同于存储在其中的值的类型。当涉及数组时，别名可能意味着使用数组边界之外的索引值，并访问存储在数组附近的另一个对象。在某些情况下，别名也可能意味着使用一个标识符来访问一个与其声明的对象明显不同的对象。C 和 C++都列出了一些允许这种访问的例外情况；但是，除此之外，混叠的影响在很大程度上没有定义。编译器依靠遵守别名限制的程序来优化代价高昂的内存读取。当一个程序违反这些限制时，就会发生不好的事情。在接下来的部分中，我将展示许多例子来说明我的意思。

### 对不同对象的访问

首先，考虑以下函数(参见编译器资源管理器中对不同对象 的 *[访问示例):](https://godbolt.org/z/Wy3JyE)*

```
	extern int a[];
	extern int b[];

	int f (int i, int j)
	{
	    int t = a[i];
	    b[j] = 0;          // cannot change a
	    return a[i] - t;   // can be folded to zero
	}
```

大多数优化编译器，包括 GNU 编译器集合(GCC)，都用常数零替换`a[i] - t`表达式，因为`a`和`b`指定了不同的对象，不能别名。不管数组索引的值如何，对一个数组的有效存储都不能改变另一个数组的值。因此，`a[i]`和`t`必须相等，相减的结果必须为零。如果`a`或`b`是指向同一类型的指针，那么同样的优化是不可能的，因为两者都可能指向同一个对象；换句话说，他们可以化名。

除非不恰当地使用了某个常见的编译器扩展，否则程序无法避免这种优化。当我在第 2 部分讨论别名和弱符号时，我将展示这种扩展的例子。

### 不兼容类型的访问

当指针指向不同的类型时，如下一个示例中的函数所示，GCC 和大多数其他编译器会将结果优化为零(另请参见 *[通过指向不兼容类型的指针进行访问](https://godbolt.org/z/Cmg5a3)* ):

```
	int f (int *a, long *b)
	{
	    int t = *a;
	    *b = 0;          // cannot change *a
	    return *a - t;   // can be folded to zero
	}

```

因为`a`和`b`被声明为指向不兼容类型的指针，并且因为 C 和 C++要求对象的存储值只能由兼容类型的左值访问，所以`*b`的存储不能影响缓存在变量`t`中的`*a`的值，变量【】通常是一个寄存器。因此，减法表达式中的操作数必须相等，结果必须为零。

此要求适用于访问不兼容类型结构的成员时，即使成员类型是兼容的。因此，在下面的例子中，编译器可以将`return`表达式折叠为零。这是因为被访问成员的结构类型是不同的(参见 *[对不兼容结构成员的访问](https://godbolt.org/z/7d8MCz)* ):

```
	struct A { int i; };
	struct B { int i; };

	int f (struct A *a, struct B *b)
	{
	    int t = a->i;
	    b->i = 0;          // cannot change a->i
	    return a->i - t;   // can be folded to zero
	}

```

重要的是要记住，如果`a`和`b`指向同一个类型，我刚才展示的优化就无效——除非它们是用`restrict`声明的。(关于`restrict`关键词我很快会再讲。)现在显而易见的是，不管对象的初始值是多少，违反规则调用`f`并且`a`和`b`指向同一个对象仍然会返回零。但是这样的结果可能会让毫无戒心的程序员感到惊讶，并导致一个 bug。这就是为什么我们只能通过对象类型的左值来访问对象的主要原因。

如果用相同的指针调用类似于`f`的函数，看看会发生什么也是有启发性的。这样的调用将是无效的，因为需要通过其类型的左值来访问每个对象。代码的行为必然是未定义的，我们需要从这个角度考虑对代码行为的任何期望。

似乎有理由期望编译器在检测到违反这一要求时报告出来。然而，没有一个流行的编译器发出这样的警告(参见 *[通过指向不兼容类型的指针进行无效访问](https://godbolt.org/z/iwPg9P)* )。

### 对不同数组元素的访问

如下例所示，编译器也可以将`return`表达式折叠为零(参见 *[访问矩阵的不同数组元素](https://godbolt.org/z/spSF8e)* ):

```
	int a[2][2];

	int f (int i, int j)
	{
	    int t = a[1][j];
	    a[0][i] = 0;          // cannot change a[1]
	    return a[1][j] - t;   // can be folded to zero
	}

```

这一次，基本原理更加微妙:它依赖于每个访问中的索引必须在每个维度的数组边界内的要求。函数中访问所涉及的两个数组——即`a[0]`和`a[1]`——是更大的数组`a`的不同元素，因此它们不能彼此混淆。存储到`a[0]`的两个元素中的任何一个都不会影响`a[1]`的任何一个元素的值。因此，如果`a[1][0]`最初不为零，无效调用`f (2, 0)`可能会返回意外结果。在修改后的示例中看到的 [-Warray-bounds](https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Warning-Options.html#index-Warray-bounds) 警告检测这些无效数组引用的子集(参见 *[对矩阵](https://godbolt.org/z/pRLqRF)* 的不同数组元素的重叠访问)。

### 访问成员数组

从概念上讲，每一个普通的非数组对象都可以看作是一个一元数组的一个元素。两者之间唯一的区别是语法。此外，因为每个对象在内存中被表示为一个连续的字节序列，我们可以认为每个对象——包括一个`struct`及其成员——都是这样一个序列。然而，除了按字符类型访问的特殊情况(参见第 2 部分中的“按字符类型的别名”)，我们必须将对数组成员的访问限制在数组的边界内。将数组成员视为与其相邻的其他成员的别名是无效的。作为一个例子，考虑下面的函数(也见 *[访问成员数组](https://godbolt.org/z/Aaqz_R)* ):

```
	struct A { char a[8], b; };

	int f (struct A *p, const char *s)
	{
	    int t = p->b;
	    for (int i = 0; ; ++i)
	        if (!(p->a[i] = s[i]))   // cannot change p->b
	            break;
	    return p->b - t;             // can be folded to zero

	}

```

在这个例子中，`for`循环对`p->a[i]`的赋值只能修改`p->a`数组的元素。与前面的例子类似，我们不允许在子对象的边界之外写入到`struct`的相邻成员中。问题不在于成员之间的潜在填充，而是写在子对象的边界之外将意味着不同命名的对象会产生别名。由于这个限制，编译器可以再次将`return`语句中的减法折叠为零。您可以在 GNU 编译器集合(GCC)和英特尔 C++编译器(ICC)中找到这种优化。

## 进一步的限制

C 和 C++语言中的一般限制使编译器能够针对许多用例进行优化。然而，程序员经常必须满足我们代码中更严格的约束，如果没有附加注释，编译器可能无法推断出这些约束。在这一节中，我们将考虑由语言标准指定或作为编译器扩展提供的注释。

### `restrict`关键字

`restrict`关键字是 C 中的一个类型限定符。虽然 C++没有正式指定它，但编译器通常在`__restrict`或`__restrict__`的替代语法下支持它。我们可以将这个限定符应用于指针，也可以应用于 C++中的引用。在这两种情况下，添加限定符表明引用的对象不是通过不同的表达式读写的。我们也可以假设这些表达式不是基于同一个指针。

`restrict`的正式定义有点复杂，但基本用例很简单:它用于限定一个或多个函数指针参数，以表明该函数访问不重叠的对象。在 C++中，用例可以包括`this`指针，以及任何引用参数。作为一个例子，下面是在标准`strcpy`函数的声明中使用的`restrict`:

```
	char* strcpy (char * restrict *dst*, const char * restrict *src*);

```

这个声明表达了一个约束，即函数不能存储到`dst`所指向的数组的任何元素中，它也通过`src`从数组中读取。因为编译器通常“知道”许多标准函数的效果，所以这个约束主要对用户定义的函数有用。因此，例如，使用`restrict`来声明指针参数将打开优化机会，如通过指向不兼容类型的指针的[访问的示例所示，甚至是指向相同类型的指针(也参见受限指针](#accesses-via-incompatible-types) 的 *[访问):](https://godbolt.org/z/En-Zhi)*

```
		int f (int * restrict a, int * restrict b)
	{
	    int t = *a;
	    *b = 0;          // cannot change *a
	    return *a - t;   // can be folded to zero
	}

```

自然地，传递`f`同一个对象的地址(或者事实上，甚至是不同的地址，这会导致函数的重叠访问)违反了限制，并导致意外的结果(参见 *[违反受限指针](https://godbolt.org/z/rSdrSd)* )。当`a`和`b`完全重叠时，GCC[-re strict](https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Warning-Options.html#index-Wrestrict)警告检测到这个问题，但是只有当两个指针是同一个对象时。尽管有警告，GCC 仍然将减法折叠为零。这是因为它只在调用`f`时检测到问题，而且是在非常有限的情况下。它不诊断函数`g`中的等价调用。

### `restrict`关键字和`const`

使用`restrict`来声明函数指针参数对于优化函数体非常有用。我们也可以使用这种语法在函数调用中启用优化。结合`const`限定符，`restrict`限定的指针表达了以下约束:如果它所指向的对象被任何方式访问，那么在指针本身的生命周期内，它不能被修改。

因为`f`不能修改其参数所指向的对象，编译器有可能将下面函数中的`return`表达式折叠为零(参见 *[受限常量指针参数](https://godbolt.org/z/o9-mxV)* ):

```
	void f (const int * restrict);

	int g (int *a)
	{
	    int t = *a;
	    f (a);           // cannot change *a
	    return *a - t;   // can be folded to zero
	}

```

如果您查看这个例子的现场演示，您会发现我测试的编译器还没有利用这种优化。

在没有`restrict`限定符的情况下，限制`const`指针参数是不安全的。首先，这种语言不阻止修改由`const`限定的指针指向的对象，除非对象本身被声明为`const`。因此，程序将指针的*常量*丢弃并使用结果修改对象是有效的。第二，假设我们在没有`restrict`的情况下尝试了上面的例子。如果函数`f`有办法访问`p`指向的对象，通过除了`p`之外的其他方式，它甚至可以修改它而不丢弃它的参数的常量。使用`restrict`限定符，结合从`g`中的`*a`读取，排除了这两种可能性；它有效地保证了对`f`的调用不会以任何方式修改它所传递地址的对象。

在标准 C 中，我们可以在函数原型范围和块范围内同样有效地应用`restrict`关键字。由于它的传递性，我们可以使用`restrict`来表达别名保证，甚至不用修改 API。例如，下面的函数(见 *[受限局部常量指针变量](https://godbolt.org/z/FDPETX)* )等同于前面的代码，可以进行类似的优化:

```
	void f (int *);

	int g (int *a)
	{
	    const int * restrict p = a;
	    int t = *p;
	    f (a);           // cannot change *a
	    return *a - t;   // can be folded to zero
	}

```

和前面的例子一样，没有编译器(包括 GCC)使用这个限制来优化代码。

### 关于`restrict`的结束语

如果`f`要修改`a`和`p`指向的对象，编译器基于`restrict`关键字做出的任何优化假设(比如将`return`表达式折叠为零)都会导致未定义的行为。有鉴于此，人们可能希望编译器至少能检测出最明显的对`restrict`的误用，并发出警告。不幸的是，没有已知的编译器。因此，`restrict`既危险又有用。

### 属性`const`、`pure`和`noalias`

一些编译器提供扩展来指定额外的别名限制。GCC 及兼容编译器支持 [`const`](https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Common-Function-Attributes.html#index-const-function-attribute) 和 [`pure`](https://gcc.gnu.org/onlinedocs/gcc-9.2.0/gcc/Common-Function-Attributes.html#index-pure-function-attribute) 函数属性。我们可以使用这些属性作为优化提示，声明一个函数，要么根本不访问可观察的程序状态(属性`const`)，要么只通过读取该函数的指针参数所引用的对象来访问(属性`pure`)。

Visual C/C++和兼容的编译器支持使用`__declspec(noalias)`来声明，类似于属性`pure`，一个函数不访问程序状态，除非解引用它的指针参数。考虑下面程序中这些提示的效果(也见 *[通过函数](https://godbolt.org/z/QC99dU)* 限制走样):

```
       #if __GNUC__
	#  define NOALIAS __attribute__ ((pure))
	#elif _MSC_VER
	#  define NOALIAS __declspec (noalias)
	#else
	#  error NOALIAS not supported
	#endif

	NOALIAS int f (int *);

	int g (int *a)
	{
	    int t = *a;
	    int x = 1;
	    x = f (&x);              // can be eliminated
	    return *a - t ? x : 0;   // can be folded to zero
	}

```

我们可以假设调用`f (&x)`不改变任何程序状态，除了`x`本身，所以我们知道表达式`*a - t`可以折叠为零；因此，整个`return`语句也是如此。因此，假设函数不使用`x`的值，我们也可以消除对`f`的调用。

作为一个实验，看看当`noalias`违反了不改变程序状态的要求时会发生什么是有益的。不幸的是，尽管显而易见，但没有一个被测试的编译器诊断出这个错误(参见 *[违反函数别名限制](https://godbolt.org/z/rRMyQy)* )。有些人似乎察觉到了这一点并采取了行动，而其他人只是在某些情况下试图缓解这一问题。其他编译器完全忽略它。鉴于未定义的行为是违反显式需求的结果，除了缺乏诊断之外，这些都不足为奇。与`pure`或`noalias`要求相反，编译器检测函数何时修改非局部状态并不困难。令人遗憾的是，到目前为止，没有人这样做。

## 第一部分的结论

在本文的第 1 部分中，我重点介绍了 C 和 C++语言限制的细节以及它们在优化代码中的有益效果。在第 2 部分中，我将展示流行编译器中的各种豁免，开发者可以使用它们或多或少地安全避开别名限制。我还将讨论别名和混合访问的一些常见陷阱，以及这些陷阱可能导致的一些问题。

*Last updated: June 25, 2020*