# 红帽峰会:降低整体服务对微服务的风险

> 原文:[https://developers . red hat . com/blog/2018/05/21/red-hat-summit-low-the-risk-of-monolith-to-micro services](https://developers.redhat.com/blog/2018/05/21/red-hat-summit-lowering-the-risk-of-monolith-to-microservices)

Red Hat 的首席架构师 Christian Posta 讲述了一家虚拟公司¹T2】将一个整体应用程序迁移到微服务的故事。

当考虑风险时，我们认为我们知道可能发生的坏事以及这些坏事实际发生的概率。Christian 将 *monolith* 定义为由不同团队多年开发的大型应用程序，该应用程序提供了业经验证的商业价值，同时非常难以更新和维护。它的建筑一度很优雅，但随着时间的推移已经被侵蚀了。这使得评估整体迁移的风险变得困难。

让我们听听新学校的说法:

> 微服务是一个非常容易让人分心的词，它会让开发人员、架构师和 IT 领导误以为我们实际上可以拥有一个乌托邦式的应用架构。

嗯，不。虽然这有点愤世嫉俗，但却是事实，正确的定义是:

> [*微服务*是一种*架构优化*](https://developers.redhat.com/topics/microservices/) ，它将应用程序的模块视为独立拥有和部署的服务，目的是提高组织的速度和消除技术债务。

IT 组织的绩效与业务绩效密切相关，可以提高生产率、盈利能力和市场份额。过去几年中高绩效者与低绩效者的统计数据包括将代码从提交转移到生产*快了 200 倍* ³ ，部署快了*46 倍*，变更的交付时间快了*440 倍* ⁴ 。诸如容器、自动化测试和部署管道之类的技术和技巧可以让团队走得更快。此外，高绩效的团队引入错误的比率要低得多，并且从他们确实产生的错误中恢复的比率要高得多。

当考虑微服务时，目标不是盲目地追求微服务架构。目标是在有意义的地方使用微服务。具体来说，使用微服务来加快开发速度，降低坏事发生的风险，并在坏事发生时更容易理解和恢复。(当然，他们可能会这么做。)

Christian 涉及的案例研究是 [TicketMonster 演示](https://developers.redhat.com/ticket-monster/)。该代码最初是为 JBoss 编写的，已经存在了至少十年，用 Christian 的话说，已经变成了“一片泥沼”。出于一长串的原因，维护这个或任何其他的巨石是一个主要的痛苦:

*   在一个地方做出改变会对不相关的区域产生负面影响
*   我们不太相信合理的变化不会破坏其他地方的东西
*   我们花很多时间在团队成员之间协调工作
*   应用程序的结构已经损坏或不存在
*   我们没有办法量化代码合并需要多长时间
*   开发是单调乏味的，因为项目太大了(IDE 停滞不前，运行测试花费很长时间，引导时间很长，等等。)
*   对一个模块的更改会强制其他模块进行更改
*   淘汰过时的技术是困难的
*   我们可能不得不将新的应用程序建立在旧的方法上，比如批处理
*   在管理资源、分配和计算时，monolith 有自己的方式。

所有这些因素都使得微服务很有吸引力。但重要的是要记住*微服务是为了优化速度*。您需要问自己这样一个问题，“我们的应用程序的架构是阻碍我们更快前进的瓶颈吗？”如果不是，Christian 提出了一个三步走的过程:

1.  找出*是什么*阻止你前进得更快。
2.  修好它。
3.  回来再看看微服务。

如果微服务非常适合你，问题是如何将一个整体分成微服务。一些常见的方法包括，“做一件事，并把它做好”，“围绕动词组织”，“围绕名词组织”，以及“关注产品而不是项目。”然而，我们曾经说过类似的关于 SOA 的事情。“服务是自治的”，“松耦合是至关重要的”，“边界是明确的”，这些同样高尚的目标经常让我们无法实现。因此，我们对系统应该是什么样的老生常谈，但对如何实现它却没有真正的指导方针。更复杂的方法:

*   识别模块和边界(*又名*使用[领域驱动设计](https://en.wikipedia.org/wiki/Domain-driven_design))
*   与业务能力保持一致
*   识别负责特性和模块的数据实体
*   将这些实体分离出来，用 API 或服务将它们包装起来
*   更新旧代码以调用新的 API

这一切都很好，但它错过了很多细节。像往常一样，现实抬起它丑陋、尖尖的小脑袋，呈现出无法回避的难题:

*   模块化一个整体并不容易。如果是的话，多年来维护这个庞然大物的团队会保持它的模块化。
*   SQL 数据库通常具有紧密耦合和完整性约束。这一点经常被忽视。支持 monolith 的数据库可能已经有了规范化的表和引用完整性。忽视这一点可能是灾难性的。(事实上，这几乎肯定会是灾难性的。)
*   很难理解数据库中哪些模块使用哪些表。
*   尽管这很吸引人，但我们不能关闭企业来进行迁移。
*   会有一些丑陋的迁移步骤，不能希望消失。你必须消除多年来积累的现有技术债务。
*   最后，可能会有一个收益递减点，在这个点上，从整体中再分离出任何东西都是没有意义的。

还有一个清单——你需要确保这些东西都到位:

*   现有项目 ⁷ 的测试覆盖(考虑 [Arquillian](http://arquillian.org) 进行集成测试。还可以考虑迈克尔·费哲的书[有效地处理遗留代码](https://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052)。)
*   某种程度的监控，以检测问题、异常等。
*   一些级别的黑盒系统测试和负载测试(JMeter 和 T2 加特林可以在这里提供帮助)
*   可靠地部署到环境的能力(OpenShift 或 Kubernetes)
*   某种 CI/CD 管道，使变更更经济

继续看整体样品...Ticket Monster 代码内置了 UI。如果可能的话，一个好的第一步是将 UI 从整体中分离出来。这让您可以自由地将 UI 带入现代时代，同时也为微服务架构所承诺的关注点分离奠定了基础。首先，通过取出所有的 JavaScript、CSS 等，制作一份独立于整体的 UI 代码的副本。新的 UI 简单地调用了 monolith 的后端系统。然后，您可以对新 UI 进行暗启动或金丝雀部署，只向它发送一些生产流量，因为您验证了新 UI 在功能上等同于原始 UI。

考虑到这一点，Christian 强调了部署和发布之间的区别。一个*部署*仅仅是一个存在于生产服务器上的代码，但是没有任何流量。在生产环境中使用实时数据之前，它不被认为是一个*版本*。部署对业务来说应该是无事件的。开发人员应该能够部署代码，而无需管理员或 ops 人员的批准或干预。另一方面，决定将生产流量路由到部署是在部署经过全面测试后做出的业务决策。

在 OpenShift / Kubernetes 环境中， [Istio 服务网格](http://istio.io)使这变得容易。它是一个基础设施，允许您分离部署和发布。(阅读唐·申克(Don Schenck)对 Istio 博客系列的精彩[介绍，全面了解这项技术。)Istio 允许您说只有 1%的流量应该到达新部署，或者只有具有某些特征的用户应该看到新部署。另一个定义:](https://developers.redhat.com/blog/2018/03/06/introduction-istio-makes-mesh-things/)

> 一个*服务网格*是您的服务中的一个分散的应用程序网络基础设施，它提供弹性、安全性、可观察性和路由控制。服务网格由控制平面和数据平面组成。

Istio 通过*边车代理*工作。服务网格中的每个服务旁边都有一个代理。任何用于服务的流量首先到达 sidecar 代理。Istio 控制 sidecar 代理来确定如何、何时或是否将流量实际交付给服务。这种方法允许您管理服务网格中的所有微服务，而无需更改任何代码..

继续对 monolith 进行重构，我们可以获取 monolith 的特定功能，并将代码转移到服务中。同样，起点是从 monolith 复制代码，并将其放入一个单独的模块中。然后，我们可以使用 Istio 将部分流量路由到新服务。为了最大化我们投资的价值，我们选择的服务应该是能够提供重要商业价值的东西。换句话说，我们看着整体，并确定如果我们使它更加敏捷和灵活，系统的某些部分可以给我们带来可观的 ROI。在 Ticket Monster 的例子中，如果订单处理功能在一个独立的模块中，可以独立于 monolith 进行增强，那么它们对业务的价值会大得多。例如，如果这段代码是十年前写的，它不支持 ApplePay 或 Venmo 之类的东西。添加新支付方式的低风险架构显然有助于企业跟上潮流。

总而言之:

*   编写大量的测试。如果可以的话，是为了整块石头，但肯定是为了新的服务。
*   使用 canary 部署和其他细粒度流量控制等高级技术来管理从部署到发布的过渡。
*   减少初始服务实现中数据集成的样板代码。
*   利用技术债务为你带来优势。
*   进行大量的监控。
*   在前进的过程中，利用您的部署和发布基础设施来试验和了解您的系统。

这是一次很棒的会议，有很多基于真实世界经验的实用建议。如果你想从源头获得它，Christian 演示的[视频](https://youtu.be/YP6wJXblyWM)是 [100+红帽峰会 2018 分会场](https://developers.redhat.com/blog/2018/05/15/100-red-hat-summit-2018-session-videos-online/)之一，你可以免费在线观看。

[https://www.youtube.com/embed/YP6wJXblyWM](https://www.youtube.com/embed/YP6wJXblyWM)

祝您的企业现代化顺利！

了解 developers.redhat.com 上 **[微服务架构](https://developers.redhat.com/topics/microservices/)** 的更多信息。

**资源:**

*   [Christian 在 SlideShare 上展示的幻灯片](https://www.slideshare.net/ceposta/lowering-the-risk-of-monolith-to-microservices)
*   Christian 和 Burr Sutter 的新书:[介绍用于微服务的 Istio 服务网格](https://developers.redhat.com/books/introducing-istio-service-mesh-microservices/)
*   Christian 的书:【Java 开发人员的微服务:框架和容器的实践介绍
*   [克里斯蒂安的文章](https://developers.redhat.com/blog/author/ceposta/)关于 developers.redhat.com/blog[的](https://developers.redhat.com/blog/)

* * *

**脚注:**

1.  虚构的，但基于真实的故事。事实上，他们中的许多人。
2.  见 [Puppet.com: 2014 年发展状况报告](https://puppet.com/resources/whitepaper/2014-state-devops-report)。
3.  见 [Puppet.com: 2015 年 DevOps 状况报告](https://puppet.com/resources/whitepaper/2015-state-devops-report)。
4.  见 [Puppet.com: 2017 年 DevOps 国家报告](https://puppet.com/resources/whitepaper/2017-state-devops-report)。
5.  什么，你期待一个完整的，规范的博客帖子推荐？抱歉，但现实世界比这复杂得多。
6.  你可以用你的钢刀捅它，但你就是杀不死它。
7.  遗留代码的一个定义是“没有任何测试的代码”'

*Last updated: October 18, 2018*