# glibc 2.33 即将推出:可重新加载的 nsswitch.conf

> 原文：<https://developers.redhat.com/blog/2021/01/15/coming-in-glibc-2-33-reloadable-nsswitch-conf>

在我之前关于 nsswitch.conf 的文章中，我谈到了这个配置文件使用起来有多简单，也许太简单了。我当时没有提到的是它的内部实现有多简单。具体来说，应用程序只加载这个文件一次——第一次需要它的时候。

那么，当 [nsswitch.conf](https://en.wikipedia.org/wiki/Name_Service_Switch) 需要改变时，你会怎么做呢？如何更新所有正在运行的应用程序？你没有！强制重新加载的唯一方法是停止并重新启动应用程序。这并不总是一个选项，尤其是对于那些可能需要很长时间才能重启的关键应用程序。

GNU C 库最近的幕后工作将改变这一切。从 [glibc](https://www.gnu.org/software/libc/) 版本 2.33 开始，这个配置文件现在在每次更改时都会重新加载和重新解析，并且只重新加载配置。如果配置要求加载外部共享库，则该对象只加载一次。它可能以不同的顺序被调用，或者根本不被调用，但是它永远不会被卸载。这种行为避免了与卸载可能仍在使用的共享对象相关的一系列问题。

大多数应用程序永远不会知道这一切正在发生。他们进行查找并获得他们需要的数据，即使这与上次不同。缓存其查找的应用程序将永远不会知道发生了什么变化。问题是，如果应用程序缓存了它的一些查找，而没有缓存其他的，它可能会收到一组不一致的信息。应用程序应该已经适应了数据的变化，比如主机地址或偶尔的 UID 更新，所以改变信息的提供方式应该不会显著改变应用程序或增加程序员的负担。

我将解决一个可能出现的问题——内存。为了避免长时间运行的程序无限制地增长，解析器维护一个它看到的预解析行池，以及它提供的一组服务。它只需要将现有的数据位链接在一起。然而，这种实践假设动作排列的总数是有限的。大多数系统在几行之间循环，所以这个池的大小是有限的，如图 1 所示。一旦加载了对象，每个共享对象的数据也是固定的。

[![](img/a111eafb46a5ebed1442aff5771d2edb.png "data")](/sites/default/files/blog/2020/12/data.png)

Figure 1: Create the data for each shared object that is fixed once the object is loaded.

当然，有一个关键的警告。任何更新 nsswitch.conf 的操作都需要尽可能自动进行，这样应用程序就不会看到部分配置并试图加载它。如果您使用类似于`rsync`的工具来更新远程机器(比方说，在一个集群或计算场中，或者跨一个业务单元)，请确保您没有使用`--inplace`选项。您可能希望使用创建/复制/重命名序列，这样 glibc 就不会看到半复制的文件。

*Last updated: January 13, 2021*