# 理解 GCC 警告

> 原文:[https://developers . red hat . com/blog/2019/03/13/understanding-gcc-warnings](https://developers.redhat.com/blog/2019/03/13/understanding-gcc-warnings)

当我们的编译器让我们知道我们犯了一个错误时，我们大多数人都会感激。尽早发现编码错误可以让我们在它们让我们在代码审查中尴尬，或者更糟，变成影响客户的 bug 之前纠正它们。除了强制错误之外，许多项目通过使用`-Wall`和`-Wextra`命令行选项来启用额外的诊断。由于这个原因，一些项目甚至通过`-Werror`把它们变成错误，作为他们的第一道防线。但是并不是每个警告实例都意味着代码有问题。相反，一段代码没有警告并不能保证其中没有潜伏的 bug。

在本文中，我将更多地阐述 GCC 实现选择中涉及的权衡。除了为对实施新警告或改进现有警告感兴趣的 GCC 贡献者阐明潜在问题之外，我希望它将有助于校准 GCC 用户对什么类型的问题可以被检测到以及有什么功效的期望。对挑战有更好的理解也应该减少可用解决方案的局限性有时可能导致的挫折感。(参见[第 2 部分](https://developers.redhat.com/blog/2019/03/13/understanding-gcc-warnings-part-2/)了解更多有关中端警告的信息。)

这篇文章并不针对任何 GCC 版本，但是它提到的一些命令行选项比其他的要新。大多数是在 GCC 4 中，附带了[Red Hat Enterprise Linux](https://access.redhat.com/products/red-hat-enterprise-linux)(RHEL)，但是有些是最近的 GCC 7。示例中显示的编译器输出可能因 GCC 版本而异。如果您想使用最新的 GCC，请参见[如何在 RHEL](https://developers.redhat.com/blog/2019/03/05/yum-install-gcc-8-clang-6/) 上安装 GCC 8。

我们很少注意到即使应该发出警告却没有发出。当我们这样做的时候，通常是当我们在寻找为什么没有在开发周期的早期发现一个错误的原因的时候。只有一小部分遗漏的警告被报告给 GCC，并且那些遗漏的警告倾向于以较低的优先级处理。在某种程度上，这是不可避免的，因为其他的错误通常更重要(例如，想想编译器为有效的程序发出不正确的代码)。尽管如此，遗漏警告的报告是有用的，不仅仅是因为它们让编译器作者知道编译器没有做它宣传的事情。通常，他们还可以帮助确定错过的优化机会，否则可能会被忽视。

相比之下，抱怨代码没有问题的警告就显得突出了。在启用`-Werror`的项目中，它们是不可能错过的。我们称它们为“假阳性”，或“假警报”，或“假的”，或者有时，也许有点贬义，“假的”。但并非所有这样的警告都符合文献中定义的假阳性概念。从形式上来说，*误报*是对违反规则的报告，而该规则的定义并不支持该报告。简单来说就是警告中的 bug。

## 真正的积极与错误

作为区别的一个例子，以`-Wchar-subscripts`选项为例，其记录的目的是

> 如果数组下标有类型`char`，则发出警告。这是一个常见的错误原因，因为程序员经常忘记这种类型在一些机器上是有符号的。

因此，对任何其他类型的数组下标(包括`signed char`)发出警告都是误报。然而，尽管当`char`未签名时，没有任何`-Wchar-subscripts`的实例表明有 bug，但也没有一个是误报，因为不管`char`有无签名，警告都会被触发。这是否是一个好的设计是另外一个问题。

另一方面，如果`-Wchar-subscripts`文档改为:

> 如果类型为`char`的数组下标有负值，则发出警告。

那么只有指向负下标的实例才是真阳性，其他任何类型的实例，包括并且尤其是`char`，都是假阳性。但是，即使使用这种改进的公式，也不是这种假设性警告的每个实例都是 bug，因为数组末尾的负下标可能是有效的。这个定义会让`-Wchar-subscripts`变得多余，这很有趣，因为`-Warray-bounds`检测的正是这个警告试图阻止的那种错误，误报率接近于零。

这可能看起来是一个微妙的区别，但却是一个重要的区别，因为它决定了在 GCC 中必须在哪里实施警告才能达到令人满意的真、假阳性和假阴性率，以及这可能是多么具有挑战性。

## 前端警告

大多数 GCC 诊断、错误和警告都是在语言前端实现的。出于我们的目的，GCC 前端将程序从源代码翻译成称为 [GENERIC](https://gcc.gnu.org/onlinedocs/) 的独立于语言的形式，编译器的后续阶段将使用这种形式。前端处理解析和语义分析，并在程序的一般形式被转换成适合优化的形式之前结束( [GIMPLE](https://gcc.gnu.org/onlinedocs/) )。在转换为泛型的过程中，前端根据语言的词法、类型安全和其他静态约束检查代码，并在语言规范要求的地方发出错误。这个过程也是检查严格有效但可能不安全的结构并发出警告的机会。

### 预处理器警告

少量的 GCC 警告在预处理器中实现。这是必要的，因为在代码预处理后检测问题将不再可能。尽管 GCC 预处理器是一个独立的程序，但由于它与前端紧密集成，为了简单起见，将其视为前端的一部分是有意义的。预处理器警告的几个有趣例子是`-Wtrigraphs`检测三字符的使用，`-Wundef`识别`#if`指令中未定义宏的使用，`-Wunused-macros`帮助查找未使用的宏。

### 词汇警告

GCC 前端实现的一大类警告是基于词汇规则的警告。这些可以被认为是复杂的正则表达式。在静态分析术语中，这些规则有时被称为模式规则。这种警告的一个例子是`-Wstrict-prototypes`:它指出了没有原型(也就是说，有一组空括号)声明的 C 函数。这是有效的(尽管在 C 标准中不赞成使用)，但是因为它允许使用任意数量的任意类型的参数调用函数，所以它是不安全的，因此发出警告是有用的。该警告的其他类似变体检测相关问题:`-Wold-style-declaration`、`-Wold-style-definition`用于 K & R 风格的函数定义，以及`-Wmissing-parameter-type`用于声明函数参数而不指定它们的类型。

基于词法规则的其他有趣且有用的警告有:`-Wempty-body`针对没有主体的 if 语句，`-Winit-self`针对初始化为其自身(不确定)值的变量的定义，`-Wmissing-field-initializers`帮助检测由于缺少初始值设定项而无意中初始化为零的结构成员，`-Woverride-init`防止在使用指定的初始值设定项时用不同的值意外覆盖已经初始化的聚合成员的值， `-Wvla`由于 C99 可变长度数组溢出堆栈的倾向而使用它们，`-Wsizeof-array-argument`将`sizeof`操作符应用于使用数组形式声明的函数参数，并期望它计算数组的大小，等等。

### 类型安全警告

另一类前端警告基于类型安全的增强规则。从历史上看，c 语言一直是一种宽松的语言，其规范只对混合表达式中的类型属性施加宽松的约束。随着时间的推移，这种松散导致了错误，以至于 C++在其规范中收紧了许多相同的规则。因此，GCC 经常对严格有效的 C 和 C++结构发出警告，这些结构暗示了由于随意进行类型转换而产生的错误。

典型的例子是`-Wcast-qual`、`-Wcast-align`和`-Wcast-function-type`警告，分别针对以不安全的方式移除一个或多个限定符、增加指针目标类型的对齐或者将函数指针强制转换为不兼容类型的强制转换。其他的包括`-Wint-to-pointer-cast`和`-Wpointer-to-int-cast`选项对，用于控制整数和指针之间隐式转换的诊断。即使没有强制转换，指针和整数之间的转换在 C 中也是有效的(它们在 C++中是无效的)，但是因为它们会导致错误，所以警告有助于发现这些错误。还有一个例子，`-Wsign-compare`，检测不同符号的表达式之间的比较。

### 其他前端警告

最后一类前端警告是那些不属于以上两类的警告。通常，它们涉及一些简单形式的数据或控制流分析，或者它们需要整个翻译单元的全局视图(在大多数情况下，前端一次处理一个声明或语句)。

所有的`-Wshift-`警告(`-Wshift-count-negative`、`-Wshift-count-overflow`、`-Wshift-negative-value`和`-Wshift-overflow`)都属于这一类，因为它们的有效性取决于 GCC 确定移位表达式中一个操作数的值的能力。

类似地，一些`-Wunused`警告也在这里，因为它们依赖于 GCC 跟踪控制流的能力，或者区分没有效果的语句(`-Wunused-value`)，或者检测用属性`warn_unused_result` ( `-Wunused-result`)声明的函数的未使用结果。后面这些警告至少部分是在前端之外、在中端实现的。检测未使用的静态函数(`-Wunused-function`)的警告也部分在中间端实现，在那里它们有整个翻译单元的全局视图。

一个稍微不同的例子是`-Wtype-limits`，它检测等式和关系表达式，由于其中一个操作数的类型范围有限，这些表达式必然为真或假。为了让警告发挥作用，只需知道其中一个相等操作数的值。事实上，只有当其中一个操作数的值已知时，才会触发警告，而不是两个都已知。

## 前端警告的权衡

预处理器警告通常基于简单明了的规则，因此既不容易出现误报也不容易出现漏报。它们也很容易在无法修复且不太有趣的代码中隐藏。将不进一步讨论它们。

尽管比预处理器警告更复杂，但是词法警告通常也相当简单，并且通常具有较低的误报率和漏报率。意外实例(误报)和应该发出警告的地方遗漏警告(误报)是实现中的简单错误，很容易修复。除了请求包含诸如`-Wall`之类的选项之外，在 GCC Bugzilla 中没有针对这些选项的公开错误报告。

像词法警告一样，基于类型的警告也相对简单，并且误报率和漏报率几乎为零。前端是实现它们的合适的编译器组件。

对于那些依赖于任何类型的数据或控制流分析的人来说，前端警告的权衡成为焦点。前端根本没有足够的信息来跟踪跨语句的变量值，更不用说跨函数调用了，也没有足够的信息来确定语句是否可达。因此，这种警告容易出现假阴性和假阳性，这表明前端可能不是实现它们的最合适的选择。在接下来的几节中，我们将看看这个选择带来的问题。

### 由于缺乏持续传播而导致的假阴性

前端警告因缺乏持续传播而受到影响的一个很好的例子是`-Wformat`。警告的实现能够检查`printf`格式字符串，这些字符串要么是文字，要么是编译时常量，而不是其他。例如，当格式字符串被声明为一个`const char`数组时，GCC 可以检查它并捕捉类似这样的错误:

```
  const char fmt[] = "%s";
  printf (fmt, 123);   // checked

 warning: format ‘%s’ expects argument of type ‘char *’, but argument 2 has type ‘int’ [**-Wformat=**]

```

但是，当格式字符串被赋给一个本身不是常数的指针变量时，前端看不到它的值(因为指针的值在初始化和使用之间可能会改变), GCC 无法检测到下面同样的错误:

```
  const char *fmt = "%s";
  printf (fmt, 456);   // not checked 
```

只有在编译器的后续阶段跟踪表达式中变量的常量值(它们执行常量传播)，才有可能检测到后一个示例中的错误。

### 由于缺少值范围传播而导致的假阴性

上面提到的`-Wtype-limits`选项是这样记载的:

> *如果由于数据类型的范围有限，比较总是为真或总是为假，则发出警告，但不警告常量表达式。*

该规范使其容易出现各种各样的误报。例如，手册暗示本例中应发布`-Wtype-limits`:

```
int f (int i)
{
  if (i < 0)
    i = 0;

  return i - INT_MIN < 0;   // always false
}
```

在`return`语句中，因为`i`的值已知是非负的，并且被其类型限制为小于`-(INT_MIN + 1)`，所以比较必然是假的。令人遗憾的是，部分是由于一个 bug，但更有趣的是由于前端的值范围优化(VRP)不可用，GCC 未能诊断出这一点(以及许多类似的情况),因为它不知道`if`语句将`i`的值的范围约束为不小于零。由于 VRP 优化过程，这些信息在编译的后期阶段是很容易得到的。

### 无法访问的代码中的警告

作为假阳性的例子，考虑`-Wshift-count-overflow`和下面两个等价函数。(这个例子是故意设计的，以说明警告在实施中的局限性。有更好的编码方式。)

```
unsigned long f (unsigned long x)
{
  if (sizeof (long) == 8)
    x <<= 63;
  else
    x <<= 31;
  return x;
}

unsigned long g (unsigned long x)
{
  x <<= (sizeof (long) == 8) ? 63 : 31;
  return x;
}
```

在 ILP64 模式下，我们大多数人开发和测试软件，而`long`是 64 位宽的类型，代码编译时没有警告。但是在 32 位`long`的 ILP32 模式下，GCC 报错:

```
warning: left shift count >= width of type [**-Wshift-count-overflow**]
4 | x <<= 63;
```

该警告是一个明显的误报:`sizeof (long)`在 ILP32 中是 4，但是该警告所指向的行上的赋值只有在`sizeof (long) == 8`成立时才会发生。GCC 必须在`g()`中看到这一点，因为它不在那里发出警告，但是它不能在`f()`中确定同样的事情，因为 GCC 中的 C 前端一次翻译一条语句。在`g()`中，前端能够评估赋值表达式的右操作数，并在评估移位赋值之前将其“折叠”成 31。但是在`f()`中，即使它也将`if`语句中的条件评估为假，它仍然翻译`if`语句的两个分支中的两个赋值，即使其中一个明显是死的(编译器的后续阶段消除了死代码)。前端无法消除不可达代码是依赖流量分析的前端警告出现误报的主要原因。

在[第 2 部分](https://developers.redhat.com/blog/2019/03/13/understanding-gcc-warnings-part-2/)中，了解在 GCC 中端实现基于流的警告如何克服前端限制。

## 面向 C/C++开发人员的更多文章

*   [如何在红帽企业版 Linux 7 上安装 GCC 8 和 Clang/LLVM 6](https://developers.redhat.com/blog/2019/03/05/yum-install-gcc-8-clang-6/)
*   [GCC 推荐的编译器和链接器标志](https://developers.redhat.com/blog/2018/03/21/compiler-and-linker-flags-gcc/)—用正确的标志改进警告和代码生成。
*   [GCC 8 中的可用性改进](https://developers.redhat.com/blog/2018/03/15/gcc-8-usability-improvements/)
*   [Clang/LLVM 入门](https://developers.redhat.com/blog/2017/11/01/getting-started-llvm-toolset/)
*   [用 GCC 8 检测字符串截断](https://developers.redhat.com/blog/2018/05/24/detecting-string-truncation-with-gcc-8/)
*   [GCC 7 的隐式失败检测](https://developers.redhat.com/blog/2017/03/10/wimplicit-fallthrough-in-gcc-7/)—检测 switch 块内缺失的 break 语句。通过`-Wimplicit-fallthrough`启用警告。如果您使用`-Wextra`，这也是将启用的警告之一。
*   [使用 GCC 7 进行内存错误检测](https://developers.redhat.com/blog/2017/02/22/memory-error-detection-using-gcc/)
*   [用 GCC 插件诊断函数指针安全缺陷](https://developers.redhat.com/blog/2017/03/17/diagnosing-function-pointer-security-flaws-with-a-gcc-plugin/)
*   [更好地使用 C11 原子——第一部分](https://developers.redhat.com/blog/2016/01/14/toward-a-better-use-of-c11-atomics-part-1/)

*Last updated: March 15, 2019*