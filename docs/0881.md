# GNU C 库的平台接口

> 原文:[https://developers . red hat . com/blog/2019/03/27/a-platform-interface-for-the-GNU-c-library](https://developers.redhat.com/blog/2019/03/27/a-platform-interface-for-the-gnu-c-library)

应用程序开发人员继续需要更新版本的库，包括像 GNU C Library (glibc)这样的核心运行时。在本文中，我将讨论一些与在操作系统(OS)发行版中升级 glibc 相关的问题，我也鼓励您阅读 Florian Weimer 关于主题的精彩博文。

## 问题是

在库重定基础或继续提交的反向移植之间做出决定涉及到一系列复杂的风险和回报。对于一些客户和用户来说，重要的是不要改变库的基础(确保变更影响的最低风险)；但是对于其他人来说，rebase 带来了有价值的 bug 修复(已知问题影响的最低风险)。在其他情况下，较新的库可能性能更好，即使接口没有改变，因为它可以利用较新的硬件或较新的 Linux 内核(对先行者的性能优势)。

没有办法同时满足慢速和快速开发的所有需求。最近在 [Fedora 模块化](https://docs.fedoraproject.org/en-US/modularity/)中的工作旨在解决这个问题的根源，但这项工作有一个限制。越往下，问题就越难解决。堆的上部破损的可能性增加。无论是在构建时还是在运行时，您都不能随意更改组件的已安装版本而不承担任何后果。

## 解决方案

如果客户或用户的回报超过了风险会怎样？我们将如何部署一个重新基础的 glibc(这是 Florian 确定的概念上最简单的选择)？我们如何减轻一些最严重的问题？

我们可以这样分解一个可能的解决方案:

1.  交付新的 glibc。
2.  建立时间隔离。
3.  选择覆盖系统或应用程序的系统 glibc。
4.  使用新 glibc 对系统进行确认和验证。

对于每一步，我将讨论如何减少或减轻重定基数带来的问题。

## 交付新的 glibc

从根本上来说，最简单的解决方案是改变整个库的基础，并接受后果。通过模块化，我们能够在一个独特的 rpm 存储库中交付库的替代版本。如果特定用户认为风险和回报是值得的，他们可以启用这些存储库。如果没有模块化，我们可以使用软件集合或者一个替代的包名(例如 glibc-alt)。

直截了当的答案是模块化和可选包名的组合提供了一个健壮的解决方案。我们必须在一个不同的路径下安装全新的 glibc，例如，类似于/opt/glibc/2.29 的路径，以及指向/opt/glibc/latest 和一个特殊的/opt/glibc/release 的符号链接。就是这样，我们有了一个新的 glibc，它不会以任何方式影响运行系统。

接下来我就说说怎么用。

## 构建时间隔离

/opt/glibc/release 中安装了什么？作为发行版的一部分，头文件和库的确切集合都是以可选系统根的形式发布的。这在工具链术语中称为“sysroot”，你可以用`--sysroot`将你的编译器和链接器指向它，这个路径可以优先用于编译应用程序(包括使用`-Wl,-rpath`和`-Wl,--dynamic-linker`)。

sysroot 更直白的名字应该是“glibc 平台接口”，我将在这里详细讨论这个名字。在这种情况下,/opt/glibc/release sysroot 将被用作默认的系统 sysroot，或者我们将在其中创建一个符号链接树。要点是，您总是针对发行版的“已发布”版本的库进行编译。

无论您在/opt/glibc 中安装了多少新版本的库，总有一个/opt/glibc/release 是编译应用程序的默认 sysroot。这种方法缓解了 rebase 中的一个潜在问题，即当应用程序所依赖的接口被否决时，应用程序不再编译。/opt/glibc/release sysroot 在发行版的生存期内不会弃用任何接口。

那么我们如何利用新的 glibc 呢？

## 覆盖系统 glibc

现在，您可以在发行版中安装多个版本的 glibc，缺省版本为/opt/glibc/release。你也有两种选择，这两种选择在 Florian 的文章中都有讨论，我们可以在这里实现。

您可以专门针对/opt/glibc/2.29 编译您的应用程序，并永远针对 glibc 2.29 进行链接。然而，这种方法有支持的含义，因为 glibc 2.29 可能支持有限。此时，系统 glibc 运行时可能是/opt/glibc/release 的符号链接，它提供了系统 glibc 库。

如果它的价值足以让您改变一个系统或一个容器来使用新的 glibc 呢？如果您已经确定了一个好处，那么允许一个类似于选择方案的替代方案是有价值的，其中一个符号链接可以被改变以在/opt/glibc/release 和/opt/glibc/latest(或一些其他特定版本)之间切换系统，但是仅针对运行时组件，即共享库 SONAMEs(不是仍然指向/opt/glibc/release 的 glibc-devel 符号链接)。通过快速切换`alternatives --set`，您将使用新的运行时运行所有新的流程。关键是开发者做出选择。

结果是，对 glibc 进行重新设置意味着对软件栈的其余部分进行验证。

## 新系统 glibc 的确认和验证

如何量化发行版中支持 glibc rebase 的风险？唯一的方法是实际去做，并衡量失败。除了对风险建模之外，没有其他方法，但是即使是没有数据的模型也只是基于其他测量失败的估计。我们必须着手在发行版中重新构建 glibc，以获得这种体验，并希望获得额外的好处。有趣的是，Fedora 内核已经有了类似的解决方案。

Fedora 内核团队按照交错交付的方法，对所有活跃的 Fedora 版本中使用的内核进行了重新调整。针对特定 glibc 版本的相同方法可以让我们在发行版中进行 glibc rebase 时积累大量经验。请记住，我们已经在 Fedora Rawhide 中做到了这一点，它一直在新的 glibc 中滚动。这里的要点是用 glibc 的一个新的稳定版本来更新当前的 Fedora 版本。例如，带有 glibc 2.28 的 Fedora 29 已经发布了一段时间，积累了一些错误修复和 CVE 修复。最终，将 Fedora 28 和 Fedora 27 切换到 glibc 2.28 并为所有三个活动发行版提供一个更新和刷新的 glibc 将是有益的，而 Fedora 27 和 Fedora 28 将继续使用其默认的/opt/glibc/release sysroot 来将编译时更改与这些包和用户隔离开来。

## 第一步

在 Fedora Rawhide 中，我已经添加了将 glibc 移动到 sysroot 位置所需的代码。同样，Nick Clifton 也在 Fedora binutils 包中启用了完全的`--sysroot`支持(这是我们以前没有启用的)。真正需要做的是确认和验证一个新的 glibc。我们需要积累做这些 rebases 的经验，包括知道什么不该做的经验。如果我们不能做发布 rebases，那么将很难支持另一个 glibc。例如，我们需要使用符号链接和替代方法彻底测试部署，以便在升级期间切换 glibc。

我期待跟随 Fedora Linux 内核团队的脚步。尝试稳定 glibc 的基础将为我们的用户提供更快的 bug 修复和 CVE 修复。这也将为 Fedora glibc 团队提供处理未来 rebases 所急需的经验。这一经历的结果将会产生深远的影响。

也许有一天，我们可以在以后的 Fedora 上启用全新的 glibc 作为开发者选项！