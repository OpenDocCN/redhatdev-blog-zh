# 了解你的 API 有多 RESTful:Richardson 成熟度模型概述

> 原文:[https://developers . red hat . com/blog/2017/09/13/know-how-restful-your-API-is-an-overview-of-the-Richardson-maturity-model](https://developers.redhat.com/blog/2017/09/13/know-how-restful-your-api-is-an-overview-of-the-richardson-maturity-model)

大多数时候，我看到开发人员对术语 REST 有点困惑。对于一些企业应用程序开发人员来说，REST 的含义是 JSON，也就是说，如果他们在应用程序中使用 JSON，这意味着他们在 REST API 上工作，这在某种程度上是不正确的。让我们看看 REST API 到底是什么。

假设我们设计了一个 REST API。我们怎么知道 Restful API 有多少？有些开发者称之为“非 Restful API”，有些称之为“部分 Restful API”，有些称之为“完全 Restful API”，有些称之为“根本不是 REST API，或者他们称之为基于 SOAP 的 web 服务”。想象一下从非 Restful 到完全 Restful API 的范围。要知道 API 站在哪个层次，理查森介绍一个模型叫做 ***理查森成熟度** **模型*** 。顾名思义，它讲述了 REST API 的成熟度。

根据 *Richardson 成熟度模型*，任何 REST API 都属于下面提到的从 0 级到 3 级的任何一个成熟度级别。

![](../Images/86deb4c295737e19a7cc4c090687ebe5.png)

没必要开发的每个 REST API 都要高到 3 级。但是这个模型帮助 REST API 的开发者知道他们的 API 属于哪个级别，以及他们如何通过在上面的模型层次结构中向上移动来使他们的 API 变得更好。

### ***0 级:沼泽之痘***

1.  在这一层设计的 API 根本不是 Rest APIs，这是基于 SOAP 的 web 服务发生的地方。
2.  在这个层次上，没有基于资源的 URI(T1)、超媒体(T3)和 HTTP 协议(T5)的正确使用(这些都是 REST API 的关键特征)。事实上，属于这一层的 API 没有利用或充分利用 HTTP 协议的潜力。HTTP 仅仅被视为传输层协议或者仅仅是客户端和服务器之间的隧道机制。

例如:让我们看一个 twitter API，它允许用户创建一条推文，评论一条推文，关注用户，分享推文，等等。在 0 级设计的这种 twitter API 的示例 URI 或端点可以是 *http:// <主机名> : <端口> /twitter。*

这里是服务器端的端点如何知道如何处理来自客户端的传入请求，或者执行什么操作，如创建推文、删除推文或评论推文等。此外，API 客户端如何告诉服务端点执行不同的操作？

在基于 SOAP 的 web 服务中，这是通过发送消息或请求体来完成的，消息或请求体通过 SOAP 协议发送到端点。请求体本质上包含了所有关于操作的信息(比如删除 tweet、创建 tweet、更新 tweet 等等)。)和对其执行操作的数据，例如，为了创建 tweet，请求主体可能类似于:

![](../Images/a776e55a3e25ce1d401b09975b24a3b1.png)

类似地，对于删除推文，请求主体可以<delete-tweet>...</delete-tweet>。如果在创建 tweet 时出现了一些错误，我们可能会从服务器得到类似于<create-tweet-error>错误原因</create-tweet-error>的响应。

请注意，所有这些请求都发送到一个端点，这就是端点知道如何执行不同操作的方式。由于请求体本身确定需要执行哪种操作，因此对所有操作使用单个 URI 是有意义的。或者我们可以说，相同的 http 方法可以用于 tweet 上的每个操作，因为关于操作的所有细节都在请求体(也称为 SOAP XML)中携带，并且我们没有利用 HTTP 方法/动词的潜力。因为 HTTP 在这一层仅用作客户机和服务器之间的隧道。

这被称为 POX 的沼泽(普通旧 XML)方法。因此，在 SOAP web 服务的情况下，一切都是由 XML 定义的，这被称为 POX(普通旧 XML)。

### ***一级:基于资源的地址/URI***

1.  这是 REST API 的起点。在这一级中，引入了*基于资源的地址*的概念，这告诉您服务器上的每个资源应该有单独的 URI(不像 0 级，对于来自客户端的每个传入请求，我们只有一个 URI)。
2.  这就像将单个端点(处理所有操作的 0 级端点)的负担减少到基于多个资源的 URIs，如分治算法。
    示例:创建发送给 URI1 的推文请求，删除发送给 URI2 的推文请求，等等。所以无论我们创建一个新的 tweet，删除 tweet，还是更新 tweet，操作信息(创建、更新、删除 tweet)仍然在请求体中。在上面的 twitter API 中，我们可以认为 TWEET、COMMENT 和 FOLLOWER 是上面应用程序中的不同资源。
3.  如果我们只设计了*基于资源的 URI* 而没有其他的，那么我们就处于成熟度模型的第 1 级。在这种情况下，HTTP 只是用作客户端和服务器之间的隧道，我们没有利用 HTTP 作为应用层协议的潜力。
4.  对于 REST 初学者来说，大多数开发人员都是在这个层次上设计 REST API。![](../Images/61cea0c981fbaa243f97e5969a8db0e3.png)

### ***第二层:利用 HTTP 的潜力作为应用层协议***

1.  在这一层下开发的 REST 充分利用了 HTTP 作为应用层协议的潜力。
2.  在这一层开发的 REST API 使用标准的 HTTP 方法/动词和不同的 HTTP 状态代码对资源 URI 进行不同的操作。因此，请求体将不再在这一层携带操作信息。因此，这个 API 比 0 级和 1 级开发的 API 要成熟得多。

例如:假设我们想创建一条 tweet，然后决定删除它。因此，我们将有资源“Tweet”，我们可以形成基于资源的 URI，如 http:// <host name="">: <port>/api/tweets。现在，如何告诉这个基于单一资源的 URI 做不同的操作，答案是使用 HTTP 动词，如下所示。</port></host>

创建 tweet 的 Post 请求示例如下

![](../Images/1d129fa76c05ae1c22b4a06f8f1ec21e.png)

在服务器端删除 tweet 的示例删除请求。

![](../Images/735714dda8b2a880384e7d09f065317b.png)

在本例中，我们观察到两个请求都指向单个基于资源的地址，并且操作不再由请求主体管理，我们利用 HTTP 方法在同一 URI 上执行不同的操作，请求主体仅携带原始数据，将在服务器端对这些数据执行操作。我们还使用了适当的状态代码，以便帮助客户判断操作是否成功。

### ***第三级:使用超媒体或 HATEOAS***

1.  在第 1 级中，引入了*基于资源的 URI* 概念，在第 2 级中，我们使用 HTTP 方法充分利用了 *HTTP 协议*的潜力。第三层利用*超媒体*(也称为 *HATEOAS* -超媒体作为 REST 世界中应用程序状态的引擎)，驱动 API 客户端的交互。一般来说，API 客户端不知道所有的资源端点，REST 也不怎么处理 API 文档(API 文档可以告诉 API 客户端关于所有端点的信息)，不像 SOAP 那样，我们有 WSDL，它向 API 客户端提供关于服务的信息。
2.  不同的基于资源的端点使用概念 HATEOAS 感知 API 客户端，即发送一些超媒体作为端点响应的响应，而端点响应又充当应用状态的引擎，因此命名为 HATEOAS。REST API 中的 HATEOAS 概念使得 API 自文档化，因此不需要 API 文档。
3.  在这个级别 3 开发的 API 通常被认为是完全 RESTful 的 API，这就是我们看到 REST API 魅力的地方。

例如:假设 API 客户端想要获得服务器中所有可用的 tweet 以及关于特定 tweet 的评论列表。为了获得这个信息，客户端应该知道端点和 URI 分别执行它们的任务。

![](../Images/245186c21a3f4ab6a288350539f80473.png)

如果我们仔细观察上面的例子，一旦客户机向/tweets 端点发出 HTTP GET 请求，客户机就会获得服务器中的所有 tweets 以及一些额外的信息，这些信息会传递给客户机。在这种情况下，它希望获得一条 tweet 上的所有评论，使用响应中发送的端点，这就是 Rest 世界中超媒体的概念。因此，现在客户端不需要知道端点就可以获得一条 tweet 上的所有评论，事实上，API 本身正在告诉客户端使用端点，这是作为响应发送的。因此超媒体相应地驱动了应用程序状态，这就是名字 HATEOAS(超媒体作为应用程序状态的引擎)的原因。

### ***结论:***

1.  该模型简化了 REST API 的开发过程，帮助开发者设计出成熟的 Restful API。休息是罗伊·菲尔丁最先创造的一个术语。REST 的大部分概念都是受 HTTP 协议规范的启发，该规范的作者也是 Roy Fielding，因此 REST 充分利用了 HTTP 规范的全部潜力也就不足为奇了。在设计 REST API 时，不推荐使用 HTTP 协议在客户机和服务器之间只作为数据传输媒介(即传输层)。因为 HTTP 允许您使用其规范(如 HTTP 方法、HTTP 状态代码、内容类型等)定制服务器端应用程序的行为。)，应该充分利用它，这就是我们在 REST API 中看到 HTTP 作为应用层协议的实际好处。
2.  此外，这里需要注意的一个重要方面是使用 JSON 媒体类型，因为客户机和服务器之间的 HTTP 交换并不能保证您处理的是 REST API。JSON 仅仅是 REST 世界中最受欢迎的媒体类型，因为 JSON 被认为没有 XML、XHTML、明文等其他媒体类型冗长。JSON 对象很容易被任何 web 客户端理解(例如，如果我们正在处理一个以 UI 形式显示 REST API 数据的应用程序，那么 JSON 媒体类型可能是该应用程序中的最佳选择，因为浏览器/web 客户端可以很容易地理解 JSON 对象)。
3.  简而言之，一个 Restful API 在服务器端的实现必须如下:
    ***REST =基于资源的 URI+充分利用 HTTP 规范+超媒体(或 HATEOAS)***
4.  开发 Rest API 最首选的 API 是 JAX-RS(作为 JEE 规范的一部分)和 Spring BOOT(一个开源的第三方框架)。
5.  注意，在阅读本文之前，对 HTTP 和 REST 体系结构的良好了解是必要的。

* * *

**了解** [**Red Hat Openshift 容器平台**](https://developers.redhat.com/products/openshift/overview/) **，允许您供应、管理和扩展基于容器的应用程序。**

*Last updated: June 8, 2021*