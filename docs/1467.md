# ISO C++标准会议上的红帽(2017 年 4 月，Kona):核心语言

> 原文:[https://developers . red hat . com/blog/2017/06/27/red-hat-at-iso-c-standards-meeting-April-2017-kona-core-language](https://developers.redhat.com/blog/2017/06/27/red-hat-at-the-iso-c-standards-meeting-april-2017-kona-core-language)

三月/四月的 C++会议又回到了夏威夷的 Kona，距离上次 Kona 会议只有一年半的时间。像往常一样，红帽派了我们三个人去参加会议:乔纳森·韦克利、托瓦尔·里格尔和我。

会议的头条是投票将 C++17 提交给国家机构批准。没有任何明显的抵抗。

最终草案中增加了一个新功能，即`[std::byte](http://wg21.link/p0298r0)`，预计将于去年 11 月在华盛顿州伊萨夸的会议上推出，但由于命名问题而搁浅。`std::byte`旨在代替`char`的变体用于无类型内存访问；希望在未来，我们可以从 char 中移除广泛的别名语义，从而改善 char 成员的类型优化。

像往常一样，我在核心语言工作组呆了一周。

Core 花了一周的时间讨论 C++模块和基于参数的查找。在没有模块的 C++中，每个名称空间只有一个实例，所以通过参数相关的查找可以清楚地找到什么。但是对于模块来说，这变得更加复杂，在模块 A 中定义的模板可能依赖于未导出的声明，并且依赖于参数的查找可能需要在另一个模块或导入翻译单元中查找声明。有关这些讨论的更多信息，请参见[本文](http://wg21.link/P0582)。

预期在这些调整之后，[模块工作文件](http://wg21.link/n4647)将作为技术规范进入初步投票。但在周末的委员会全体会议上，有人指出，前一年在杰克逊维尔会议上做出的一些设计选择仍然没有反映在文件中；因此，我们决定此时不进行 TS。

有些人渴望发布一个 TS 来增加实现的数量，但是我怀疑这真的会有所不同；概念 ts 并没有带来更多的实现，它也没有帮助概念成为 C++17。它甚至可能阻碍了概念的发展，因为在 ts 发布后，我们花在概念问题上的时间少了很多，甚至明确地推迟考虑重要的设计问题，以等待用户和实现者的反馈，这些反馈后来被认为是不充分的。特别是，我们在已知设计问题下发布的概念 ts 的经验应该阻止我们对模块做同样的事情。

对于模块，我不认为延迟的 TS 会是一个问题。用户强烈要求该特性，除了现有的(相当不同的)VC++和 Clang 实现之外，工作正在迅速向 GCC 实现发展。如果模块在被并入 C++20 之前一直是一份工作文件，那对我来说很好。

Core 还花了相当多的时间来解决 C++17 类模板参数演绎和演绎指南的问题，这是许多与会者关心的问题。我首先通过[起草](http://wg21.link/p0620)并对 reflector 上出现的问题实施建议的解决方案，并与库端的 Michael Spertus 一起工作了一周，以确保指定的特性具有适用于库模板的语义。

我们还讨论了 Library 提出的一个问题，即限制使用指向已被替换的旧对象的指针。在 C++98 标准之后， [core issue 89](http://wg21.link/cwg89) 指出，对于替换包含引用成员的静态或自动对象，没有像 const 对象那样的限制。作为回应，委员会增加了对指向包含 const 或 reference 成员的对象的指针的限制:如果这样的对象被替换，指向旧对象的指针不能用来引用新对象。

优化者从来没有利用过这种限制，但是在 C++14 进程的后期，人们注意到这种规则导致了几个库类的问题；这是在思考`std::optional`时发现的，但显然也会影响`std::vector`。给定一个包含引用成员的 C 类的 vector，如果我们弹出一个元素，然后在它的位置上推一个新的对象，我们能使用 vector 的内部数据指针来引用这个新对象吗？这是[核心问题 1776](http://wg21.link/cwg1776) 。

问题 1776 采用的解决方案是提供一个库函数`std::launder`,它可以用来告诉编译器忘记它所知道的指针所指的内容。所以`std::vector`可以清洗它的内部指针，然后用它来引用新对象。

在那里[继续](http://wg21.link/cwg2182)成为[担心](http://wg21.link/p0532)这还不够好，但是 Core 还没有被说服。下次会议将有一个晚上的会议来讨论这个问题。一种折衷的办法可能是削弱对指针的限制(以及潜在的优化),同时保留对引用和命名变量的限制；问题 89 最初是关于命名变量和第 10 段中的限制。独立地，对于 launder/placement new 来说，隐式地清洗基于(在 C `restrict`语义的意义上)一个公共祖先的所有指针可能是有意义的；需要使用返回值没有太大意义。

下一次会议将于 2017 年 7 月在加拿大安大略省多伦多举行。

* * *

**无论你是容器新手还是有经验的人，下载这个** [**备忘单**](https://developers.redhat.com/promotions/docker-cheatsheet/) **可以在遇到你最近没有完成的任务时帮助你。**

*Last updated: June 23, 2017*