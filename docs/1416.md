# ISO C++标准会议上的红帽(2017 年 7 月):并行和并发

> 原文：<https://developers.redhat.com/blog/2017/08/29/red-hat-at-the-iso-c-standards-meeting-july-2017-parallelism-and-concurrency>

几位红帽工程师参加了 2017 年 7 月的 JTC1/SC22/WG21 C++标准委员会会议。这篇文章主要关注并行性和并发性研究小组 SG1 的会议。我们讨论了几个与同步相关的提议，对期货的改进，当然还有执行者。此外，我还提出了 SG1 社区可以采取的一些步骤，以提高其工作效率，这些步骤都是受成功的开源项目工作方式的启发。

我们在这次会议上讨论的大多数提议都与并发性有关。[闩锁](https://wg21.link/p0666r0)被移入下一版本标准的草案中，我们在[信号量](https://wg21.link/p0514r1)、[危险指针](https://wg21.link/p0233r4)和[延迟回收](https://wg21.link/p0561r1)上取得了进展。我们讨论了内存模型中的[错误](https://wg21.link/p0668r0)，然而，这些错误似乎只出现在有争议的同步代码中，或者只是规范中的错误，而不是实际实现中的错误。修复前者的折衷似乎是在(1)降低公共同步代码的性能和(2)改变那些真正奇怪的情况下由内存模型保证的行为之间；我们很可能会接受后者，因为前者会让太多用户的性能下降太多。在我看来，对内存模型的任何更改都应该伴随着对更改的良好解释和重要工具的更新(例如 [cppmem](http://svr-pes20-cppmem.cl.cam.ac.uk/cppmem/) )。

在 C++中，futures(或 std::future)的作用尤其越来越大，这是由于最近提出了与异步执行相关的建议，并且由于更多的设施可以产生工作任务(例如，执行器),因此需要返回可能尚未完成的工作的句柄。然而，std::future 似乎并不是所有这些用途的最佳选择，我们讨论了[几个](https://wg21.link/p0667r0) [提议](https://wg21.link/p0701r0)解释设计中的问题或为 futures 提供不同的接口。

我提出了一个关于[未来的特殊问题，当它与只有较弱的前向进度保证](https://wg21.link/p0679r0)运行的执行线程结合时(即并行或弱并行前向进度，例如在某些执行策略下由 C++17 中的并行算法产生的执行线程)。我认为，如果 future 被用来阻塞这种弱进度的执行线程，那么阻塞操作应该使用带有进度保证委托的阻塞。这非正式地确保了对其他工作的依赖驱动了其他工作的执行，在我看来这是一个非常有用的特性——这也是并行算法如何安全地利用具有弱进度保证的线程。然而，当前的未来既可以用作(1)表达对其他工作的依赖性的手段，也可以用作(2)同步机制，并且进度保证委托的阻塞并不意味着后者。这是另一个迹象，表明未来的重新设计可能是有帮助的，这样就可以区分这两种不同的用例。

当然，会议中还讨论了执行者，特别是关于如何[简化之前提议的统一接口](http://wg21.link/p0688r0)的新提议。SG1 在遗嘱执行人方面正在取得进展，并且越来越接近于就一个设计达成一致，但是很遗憾，我还不能报告说我们会就一个设计达成共识。

本周结束时，我们讨论了如何改善 SG1 的运营方式，以及如何与其他参与者和其他参与者进行合作。我一直主张[做成功的开源项目所做的事情](https://wg21.link/p0680r0) : SG1、它的贡献者和我们的用户实际上是一个社区，即使 C++标准不同于拥有开源许可的代码库，我们也希望并且需要有效和高效地合作，以取得成功并为我们的用户提供良好的服务。即使只考虑 SG1 和定期贡献者，我们也可以做几件事来改善协作，这最终会使 SG1 更有生产力，因此用户可能会以更快的速度获得良好的编程抽象。我建议的具体行动是:( 1)使我们指定的编程抽象的设计背后的推理更容易理解，特别是对于不能全职参与的贡献者来说,( 2)增加我们对建立共识的关注，以及(3)使更多的工作可以在会议之间完成(即，以持续集成的精神)。我希望我们至少能在这些事情上达成一致，我期待着任何改进。

* * *

**无论你是容器新手还是有经验的人，下载这个** [**备忘单**](https://developers.redhat.com/promotions/docker-cheatsheet/) **可以在遇到你最近没有完成的任务时帮助你。**

*Last updated: August 23, 2017*