# GCC 中的值域传播与项目范围

> 原文：<https://developers.redhat.com/blog/2021/04/28/value-range-propagation-in-gcc-with-project-ranger>

在 [C 和 C++程序](/topics/c)上执行的 [GNU 编译器集合(GCC)](https://gcc.gnu.org/) 的优化之一是值范围传播(VRP)。VRP 确定变量可以包含哪些子范围，并使用该信息来消除冗余计算。这反过来使得程序更小，运行更快。

作为一个简单的例子，考虑以下 C 代码片段中的两个嵌套的`if`语句:

```
if (a < 100 && b < 100)
  {
    c = a + b;
    if (c < 200)
      foo (c);
  }
```

我们知道，如果外部的`if`语句运行它的块，`a` + `b`不能大于 99 + 99，或者 198。这意味着我们不需要检查`if (c < 200)`并且可以简单地重写代码片段:

```
if (a < 100 && b < 100)
  foo (a + b);
```

分支在程序中是很昂贵的，所以这种事情很重要。在我们担心缓冲区溢出(访问超出预期范围的数据)等安全问题的现代世界中，这甚至是一个更大的问题。编译器可能会添加范围检查或进行其他验证来强化代码，但这是有代价的。VRP 可以确定其中一些检查是不需要的。这就产生了一个更快但仍然安全的程序。我们还可以使用范围信息来识别危险的代码段，并向用户发出警告。VRP 的潜在用途越来越多。

GCC 中 VRP 的初始版本创建于 2006 年，当时静态单一赋值(SSA)是编译器中的一个新基础设施。随着对利用距离信息兴趣的重新燃起，GCC 最初版本的 VRP 根本不够灵活。在过去的十年中，已经进行了许多改进，但是仍然有一长串未完成的变更请求。底层基础设施存在太多不足，无法满足当前需求。最早的请求源于 2007 年！

## 输入项目范围

我们已经为游侠计划工作了三年多。它旨在彻底解决所有悬而未决的问题，并取代目前的 VRP 通行证。编译器中的其他过程也将能够访问这个范围信息。这种升级并非没有困难，任何试图改造 30 年代码库的人都可能经历过。早先的一篇文章涵盖了这个项目中的一些新技术。

GCC 10(当前版本)包含了一个面向对象的底层范围计算的替代品，我们称之为*范围运算*。Range-ops 负责根据每条语句求解各种距离方程。它还被预先设置为支持新的范围表示。Range-ops 是 Ranger 进入 GCC 的第一阶段。这一阶段已经运行了近一年，并继续表现良好。

即将发布的 GCC 11 版本将包含:

*   允许更精确表示的范围的新实现。
*   一个新的 Ranger VRP 基础设施可以利用这些精确的范围。
*   一个混合 VRP 通行证，仅用于此版本，其中包含 VRP 的原始版本和新版本。

其他几个通道也利用 Project Ranger 来提供一些提高速度和更好结果的组合。

## 为什么会有混血儿通行证？

Ranger 项目的开发将持续到 GCC 12，我们希望在 GCC 12 中看到该项目完全实现。没有全套的功能，我们无法完全取代原来的 VRP 通行证。

混合通道查询原始的和新的 VRP 引擎，并组合结果。这种混合通行证有助于我们优化我们过去所做的一切，以及获得一些新的机会。它还允许我们轻松地跟踪新旧方法之间的差异。不要担心，混合动力车的速度仍然很快。

主要缺失的组件是*关系处理*。本文中的第一个例子展示了如何使用范围来删除条件。有时，为了消除这种情况，必须知道操作数之间的关系。下面是一个例子:

```
if (a == b)
  if (b == c)
    if (a < c) // This can never be true
      call (b)
```

最终的`if`条件总是假的，但是我们不能仅仅根据范围来确定。这些变量中的任何一个都可能没有可辨别的范围。为了检测表达式的值，我们需要引入关系的全面知识。如果我们知道`a` == `b`和`b` == `c`，我们也可以得出`a` == `c`，因此`a < c`永远不可能为真。这看起来简单明了，但在编译器中却不那么自然。

VRP 的原始版本有许多特别的添加，允许它有时执行这种优化。这也是 GCC 11 有混合通行证的原因。这些重要的优化仍然可以执行，同时受益于 Ranger 提供的其他功能。我们也有一个完整的发布周期来比较新版本和旧版本，确保我们不会错过任何东西。

这个新的关系处理代码为 GCC 12 开发周期的开始做好了准备。我们正在利用新的系列运营基础设施来评估关系。这种增强将允许任何类型的可以计算范围的语句也提供操作数之间的关系:

```
a = b + 2    // Establishes a > b
if (a < b)   // We can fold this away since it can never be true
```

我们可以断定`a > b`后的加法，并排除`if`语句。我们希望在 GCC 12 中揭露和利用更多这些隐含的关系。

## 走向未来

Project Ranger 应该是 GCC 12 中要求的唯一 VRP 实现。我们可以删除遗留代码和它所需的各种兼容层。这将提高编译速度并减少维护工作量。最后，我们预计将有更多的通行证利用更精确的范围很容易获得。

在此基础上展望未来，我们还计划:

*   处理除整数值(浮点数、复数等)以外的类型的范围。).
*   位值跟踪(已知 0 和 1 位)。
*   利用该基础设施的额外通行证。
*   内存使用和编译速度的持续改进。

当你编译一个程序的时候，你可能不知道，但是肯定有很多新的工作在进行。GCC 11 有一些范围上的改进，但我们希望在 GCC 12 出来时解决大部分(如果不是全部的话)26 个突出的不足和特性请求。

*Last updated: October 14, 2022*