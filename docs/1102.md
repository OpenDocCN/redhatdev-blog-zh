# 2018 年 6 月 ISO C++会议行程报告(核心语言)

> 原文:[https://developers . red hat . com/blog/2018/07/02/iso-CPP-summer-2018-core-language](https://developers.redhat.com/blog/2018/07/02/iso-cpp-summer-2018-core-language)

今年的 2018 年夏季 ISO C++标准委员会会议回到了瑞士的 Rapperswil。C++2a 的新特性即将推出；核心语言工作组只有很少的时间来处理问题，因为所有的提案文件都来自演进工作组。

Red Hat 派了我们三个去参加会议，负责不同的主题:我自己(核心)、Jonathan Wakely(图书馆)和 Torvald Riegel(并行/并发)。总的来说，我认为会议很成功；我们在许多领域取得了重大进展。

本次会议上接受的新 C++语言特性:

## 公认的特征

**[契约](http://wg21.link/p0542) —** 该特性提供了一种在代码中表达函数前置条件和后置条件的结构化方式，例如

```
int f(int x)
  [[expects: x>0]]
  [[ensures r: r>0]];
```

[**非类型模板参数的文字类类型**](http://wg21.link/p0732)—这些将大致具有引用 constexpr 变量的语义。

**在 C++17 中，删除指向这样一个类的指针会用错误的大小调用 size::operator delete，有了这个建议，用户可以适当地调整大小。**

[**在常量表达式求值中允许虚函数调用**](http://wg21.link/p1064)——这个有点不言自明。

**[显式(bool)](http://wg21.link/p0892)**——c++标准库中的各种包装类型当前需要使用带有两个单独构造函数的 SFINAE，以便根据包装类型的构造是否显式来使构造显式。有了这个特性，库作者可以编写一个条件显式的构造函数。

我想引起大家注意的一个语义变化是:

**[禁止使用用户声明的构造函数](http://wg21.link/p1008)** 进行聚合——目前，一些代码使用如下模式:

```
struct A
{
  A() = delete; // prohibit default-initialization
  B b;
};

A a = { B(); }; // OK, aggregate initialization
```

鼓励 A 类型的用户使用聚合初始化。但这也允许:

```
A a = { }; // also aggregate initialization
```

删除的默认构造函数可能也是为了防止这种情况，因为它也是从无元素初始化的。所以这个提议把一个，或者任何一个有用户声明的构造函数的类，变成非聚合的；如果作者想要聚合初始化，他们必须删除默认的构造函数声明。我认为复制和移动构造函数应该有一个例外，但是失败了。但是仍然可以通过使用带有最近添加的[[no_unique_address]]属性的尾随空成员来防止聚合的默认初始化:

```
struct B { B(); };

struct deleted_default { deleted_default() = delete; };
struct A
{
  B b;
  [[no_unique_address]] deleted_default _d; // prevent default-initialization
};

A a;           // error, deleted implicitly-declared default constructor
A a2 { };      // ok, aggregate initialization
A a3 { B() };  // ok, aggregate initialization
```

## 没有被接受的论文

我们还做了几份报告，但到周末还没有准备好，包括:

*   [char8_t 类型为 UTF-8 字符](http://wg21.link/p0482)，与现有的 char16_t 和 char32_t 类型一起使用。char8_t 不会有普通 char 有问题的别名属性。
*   [带括号的聚合类](http://wg21.link/p0960)的初始化，在重载解析中被视为内置构造函数，接受聚合元素的类型。

## 概念、模块和协程

三大特性 tse(技术规范)仍在努力达成共识。

*   **概念**(去年部分合并)——有很多关于简洁函数声明语法的讨论，探索 ts 中语法的替代方案，我认为事情看起来有希望在下一次会议上达成成功的妥协。
*   **模块—** 模块似乎也在成功妥协的轨道上；大家一致同意将 ATOM 提案的一些内容合并到 TS 工作文件中，我们将在下次会议上看到结果。
*   **协同程序—** 在会议结束时，合并协同程序 TS 被提交投票表决，但是失败了。会上考虑了一个替代方案，但是下一步对我来说不像概念和模块那样清晰。

在这次会议上，我们还投票决定发出(静态)反射测试以征询公众意见。这个提议使用元类型作为句柄，用户可以通过它询问关于程序的问题，就像类型特征使用类模板一样。

周末讨论核心问题时，有一点非常有趣:

[**2335**](http://wg21.link/cwg2335)——在核心工作组(CWG)中似乎有一个越来越多的共识，即我们应该对延迟解析区域之间的依赖关系更加灵活，允许按需解析，就像我们在类模板中按需实例化这样的区域一样。这在以前被认为是不切实际的，但是现在已经不那么担心了。

下一次会议将于 11 月在圣地亚哥举行。

*Last updated: February 4, 2019*