# 打破集装箱的整体结构

> 原文:[https://developers . red hat . com/blog/2017/05/04/breaking-the-container-monolith](https://developers.redhat.com/blog/2017/05/04/breaking-up-the-container-monolith)

![](../Images/4d4c60577c25fa2ff10782a5b1fbda75.png)

因 [SELinux 填色本](https://github.com/mairin/selinux-coloring-book)而出名的 Dan Walsh ，展示了他和他的团队在容器方面所做的工作。Dan 长期以来一直是容器和 SELinux 领域的技术领导者，是一个了不起的人。

如果您花点时间回想一下 PDF 格式，它最初是由 Adobe 创建的，用于以一致的方式表示文档。然而，这并不是它流行和有用的原因。PDF 格式的强大之处在于它是开放的，并且有大量的工具来读取和写入它们。这就是 PDF 格式无处不在的原因。丹认为容器也需要如此。它们需要像 PDF 格式一样通用，使用多种创建和运行时工具。竞争孕育更好的软件，并最终产生更好的标准。

如果你看一下容器，容器只是标准映像格式的 linux。那么，OpenShift/Kubernetes 运行容器需要什么呢？它需要一个标准的容器格式。它需要一种向/从注册中心拉/推容器的方法。它需要一种方法将容器分解到磁盘上。它需要一种方法来执行容器映像。最后，也是可选的，它需要一个容器管理 API。红帽一直在“原子工程”的旗帜下致力于解决这些问题。这是一组工具，都在一个名为 *atomic* 的 CLI 命令下。

### 标准容器图像格式

开放集装箱倡议(OCI)提供了 OCI 图像格式来标准化集装箱图像格式。这就是允许开发其他任何东西的原因，就像现在有了容器的“PDF”。

### 注册表交互

原子 CLI 使用 Skopeo (希腊语“远程查看”)。它的目的是在注册表中查看容器元数据，而不需要下载完整的图像。它现在也可以拉/推图像。Red Hat 与 CoreOS 合作将其拆分成一个围棋库，现在可以在 [Github](https://github.com/containers) 上下载。

### 分解图像本地存储

对容器的一个关键需求是一种无需实际运行就能挂载容器映像的方法。这在很多地方都是有用的和必需的。例如，如果您想对容器运行 OpenSCAP 扫描以确保它没有严重的漏洞，那么您并不想实际执行容器。您需要一种以标准方式装载数据的方法。现在，使用“原子挂载”命令可以做到这一点。当然这个项目可以在 [Github](https://github.com/containers/storage) 上找到。

### 执行容器

容器的执行由完整的 OCI 标准，即 OCI 运行时规范来处理。这个标准描述了容器在磁盘上的样子。runc 是这个标准的默认实现。从 Docker 1.11 开始， *runc* 是默认的后端。还有几个其他的运行时实现， *runv* 和 *clear* 是备选方案；但是 docker 只支持 *runc* 作为后端。运行时标准允许类似 PDF 的工具链生态系统。

这些不同的组件构成了运行容器的最低要求。也就是说，容器空间也可以使用从完整的 linux 发行版借来的其他概念。

### 容器签名

该行业需要一种以开放和可伸缩的方式对容器进行签名的方法，类似于 GPG 信任网。奇怪的是，现在集装箱可以与 GPG 签约；此外，签名可以与图像分离。它们也不特定于任何注册表。现在，您可以信任由可信组织生产的容器，并验证它们没有被更改。你可以在这里找到一个签名示例[，在这里](https://www.youtube.com/watch?v=0yoQu-YylwA)找到一个管理信任的示例[。](https://youtu.be/93-71phWiOg)

### 系统容器

Red Hat 在过去几年中开发了 Atomic Host。Atomic Host 是一个基于 RHEL 的操作系统，但是是为以轻量级的方式运行容器而设计的。在原子主机上，软件是作为容器运送的。Dan 认为未来的操作系统将是一个非常基础的操作系统，系统服务和其他一切都将作为容器安装。Atomic CLI 现在可以使用 *Skopeo* 下拉图像，使用[T3】OSTreeT5】在磁盘上存储图像层，然后创建 systemd 单元文件，然后使用 *runc* 运行容器。注意，这里不涉及守护进程，这对引导过程很重要。这允许 *etcd* 和*法兰绒*在容器运行之前启动！甚至开源 docker 现在也可以作为系统容器运行。](https://ostree.readthedocs.io/en/latest/)

### 独立容器

独立容器是一种以容器形式提供普通 RHEL 内容的方法，而不是使用 RPM。守护程序在容器中运行，容器带有为标准使用情况预先打包的标准端口和卷。想想 Apache 在引导时启动、监听特权端口、读取本地内容等等。

### 改进的存储

只读容器图像应该是默认的，但目前不是。在生产中，图像应该是不可变的。这将允许我们摆脱 COW 文件系统，提高存储性能。对于只读容器来说，共享文件系统也是一个巨大的优势。目前，为了让集群中的运行时运行容器，必须将该容器从注册表中取出并存储在本地存储上。迁移到 NFS 存储模式将显著改善性能和映像管理。不是必须将新容器推送到注册表，只是为了让所有的 OpenShift 节点都可以下载它，而是浪费了大量的 CPU、存储和网络资源。丹的团队正在通过支持基于网络的存储来解决这个问题。

### 容器图像开发工具

Dockerfile 烂透了。这是事实。四年过去了，我们仍然不得不使用 Dockerfile，这是 bash 的一个可怕版本。tarball 中的图像和核心的 json 文件。我们现在有了 Ansible-Containers，这给了我们描述容器化应用程序的另一种方式；但是，它仍然在引擎盖下使用 Dockerfile。我们需要一种不用容器运行时守护进程来构建映像的方法。这就把我们带到了 *[Buildah](https://github.com/projectatomic/buildah)* ，这是一个完全不使用 Dockerfile 构建容器的开源工具。这个工具还允许我们在没有所有容器开发工具(yum、GCC、secrets 等)的情况下构建容器。基本上， *Buildah* 生产干净的容器，这意味着容器可以小得多。它甚至支持在 Dockerfile 文件中读取以生成容器，但这种做法没有意义。

### 容器管理 API

红帽开始致力于这项工作。它不是 docker 的一种形式，而是支持 Kubernetes 容器管理 API，或者换句话说，“它使用符合 OCI 标准的运行时来实现 Kubelet 容器运行时接口(CRI)”。Kubernetes 与 CRI-O 通信，CRI-O 反过来执行容器。

Dan 在 Red Hat 的团队一直致力于将开源开发、原则和概念引入容器生命周期。虽然容器到目前为止都是开源的，但是容器管理系统是一个巨大的整体。将容器分解成单独的组件可以实现快速创新。这些组件都在进化、被开发、分叉，甚至允许全新的工具来满足容器生态系统的需求。这些努力现在得到了回报，容器的前景也因此变得更好了。

* * *

**无论你是容器新手还是有经验的人，下载这个** [**备忘单**](https://developers.redhat.com/promotions/docker-cheatsheet/) **可以在遇到你最近没有完成的任务时帮助你。**

*Last updated: April 8, 2021*