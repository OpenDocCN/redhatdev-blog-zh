# 2019 年 2 月 ISO WG21 C++标准委员会会议报告

> 原文：<https://developers.redhat.com/blog/2019/06/21/report-from-february-2019-iso-wg21-c-standards-committee-meeting>

2019 年 2 月 [ISO C++会议](https://isocpp.org/std/meetings-and-participation/upcoming-meetings)在夏威夷凯卢阿-科纳举行。像往常一样，Red Hat 派了我们三个人参加会议:我参加了 SG1(并行和并发)组，Jonathan Wakely 参加了图书馆，Jason Merrill 参加了核心工作组(见 Jason 的报告[这里](https://developers.redhat.com/blog/2019/04/11/report-from-the-february-2019-iso-c-meeting-core-language-working-group/))。在这份报告中，我将介绍会议的一些亮点，重点是讨论的文件。

在 SG1 的这一周的第一部分主要花在与执行人提案有关的文件上。首先是“将执行器与并行算法集成”( [p1019](https://wg21.link/p1019) )。SG1 在圣地亚哥的秋季 WG21 会议上也看到了这篇论文(见我的【2018 秋季旅行报告)。Kona 中围绕这篇论文的大部分讨论集中在为算法提供一个执行器是否要求算法必须在所提供的执行器上执行。目前，执行策略只是对算法的提示，算法可以随意忽略该提示(例如，一些算法没有有利可图的并行化，或者并行化对于小的输入范围可能没有好处，因此算法可以忽略用户对并行化的请求)。

我们还花了一些时间试图获得在 [p1019](https://wg21.link/p1019) 的上下文中什么被算作执行线程(ToE)的更清晰的定义(例如，ToE 是否意味着 TLS？纤维呢，SIMD 巷等等。？)和标准并行算法，以及如何处理异常。目前，并行算法中的异常会终止调用程序。一致的意见是，我们希望针对提供给算法的执行器，要求算法在提供的执行器上严格执行。作者被要求根据这一指导意见对论文进行后续修订。关于异常传播的话题或者在这个上下文中什么具体构成了 ToE，还没有得出结论。

接下来简单讨论了一下我为秋季会议写的一份体验报告( [p1192](https://wg21.link/p1192) )。我没有关于 Kona 这篇论文的新信息，但我希望带来一个更新或一篇基于我将做的工作的新论文，以将并行算法的 libstdc++实现的默认执行后端从英特尔的线程构建模块替换为基于 OpenMP 的后端。

我们还看了一篇为执行器提出“占用”属性的论文( [p1259](https://wg21.link/p1259) )，它可以向并行算法传达最大可用并行性的一些度量。SG1 花时间讨论如何用文字表达这种属性实际传达的内容。SG1 最终选择了一些新的措辞，并将文件转交给 LEWG，与主要执行人文件(p0443)放在一起。

周一下午，我们考虑了一些与网络相关的论文:

*   “网络 TS 增强功能，支持自定义 I/O 执行器”( [p1322](https://wg21.link/p1322) )
*   “重新考虑包含在 C++20 中的网络 TS”([p 1446](https://wg21.link/p1446))
*   “将大部分网络 TS 并入 C++工作草案”( [p1259](https://wg21.link/p1259) )

第一篇文章(第 1322 页)描述了对网络 ts 的更改，以允许实施提供超出 TS 所识别的自定义 I/O 上下文(当前实施通过调用获取线程。对 io_context 运行()。与会者一致同意将提议的修改纳入网络技术服务当前的工作草案。

对 p1446 的讨论主要集中在如果 LEWG 移动 C++20 的执行程序该怎么办。如前所述，p1322 与 SG1 在圣地亚哥批准的( [p0958](https://wg21.link/p0958) )一致同意合并到当前的网络 TS 草案中。还一致同意网络 TS 的任何未来版本必须包括这些变化。LEWG 在圣地亚哥做出的不推进 C++20 网络的决定认为 p1253 没有实际意义。

SG1 周一考虑的最后一篇论文是 p1478r0(它不在会前邮件中，但应该在即将到来的会后邮件中)。本文提出了一种基于字节的原子内存的形式化定义。这篇文章关注于 Seqlocks(参见[https://dl.acm.org/citation.cfm?doid=2247684.2247688](https://dl.acm.org/citation.cfm?doid=2247684.2247688))作为这个特性的一个用例，并且预计 memcpy 的大多数现有实现已经“做了正确的事情”因此，本文建议添加两个额外的 memcpy 版本，它们也接受 memory_order 参数:

*   原子 _ 源 _ 内存
*   原子 _ 目的 _ 记忆

这可能被实现为现有 memcpy 实现的别名。

周二早上，SG1 看了一些关于协程和执行器交集的论文，这些论文都比 C++20 更有前瞻性。讨论的论文有:

*   “经验报告:实现一个协同程序 TS 前端到现有的
    任务库”( [p1403](https://wg21.link/p1403) )
*   “更好地整合发送者执行者”( [p1349](https://wg21.link/p1349) )
*   “在 C++标准库中统一异步 API”([p 1341](https://wg21.link/p1341))

周二下午，LEWG 和 SG1 举行了一次联席会议，讨论执行人和执行人提案中作为独立设施的财产机制([https://wg21.link/p1393](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1393r0.html))。一致的意见是将 p1393 转发给 LWG 进行下一步的 C++开发。这实际上意味着，除了联网之外，C++20 不会附带执行器。

周三，SG1 考虑了撤回并发 TS ( [p1445](https://wg21.link/p1445) )的请求。前提是大多数并发 TS 将作为 C++20 的一部分发布，其余的元素取决于执行器的情况。SG1 投票赞成撤销 TS。

SG1 考虑的下一篇论文是第二个并发 TS ( [p09402](https://wg21.link/p0940) )的提案，旨在收集第一个并发 TS 中不属于 C++20 的那些特性，以及 SG1 在过去几年中一直在关注的几个新特性，例如:

*   与遗嘱执行人相关的设施
*   并发数据结构(并发队列、关联容器、计数器)
*   新的同步原语(单元、危险指针、RCU)
*   堆叠的冠状纤维(又名纤维)

SG1 总体上赞同这一做法。

SG1 还讨论了几篇与并发数据结构相关的论文:

*   “并发 TS 正在增长:并发实用程序和数据结构”( [p0940](https://wg21.link/p0940) )
*   “视图不同步的并发关联数据结构”( [p0652](https://wg21.link/p0652) )
*   “并发数据结构的内存模型问题”( [p0387](https://wg21.link/p0387) )

周四，SG1 考虑了一些文件:

*   “通过提供定制点，给予 atomic_ref 实现者更多的灵活性”( [p1372](https://wg21.link/p1372) )。
*   “贬低挥发”( [p1152](https://wg21.link/p1152) )。本文件旨在将更有问题的 volatile 用途移至附件 d，SG1 投票决定将其转交给 EWG。
*   “volatile_load <t>和 volatile _ store<t>”([p 1382](https://wg21.link/p1382))。本文与 p1152 相关，旨在提供一种标准支持的(与标准实际上所说的 volatile 相反)访问共享/内存映射区域的方法。SG1 总体上赞同本文的方向。</t></t>
*   “不对称围栏”( [p1202](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1202r1.pdf) )。本文提出了支持用例的标准化设施，在这些用例中，并发访问可以被分成常见的“快速路径”和不常见的“慢速路径”SG1 共识是转发给 LEWG 纳入并发 TS2。
*   “并非所有代理都有 TLS”([p 1367](https://wg21.link/p1367))。本文的目的是在标准中加强对线程局部变量的定义。
*   “基于亲缘关系的执行的执行器属性”( [p1436](https://wg21.link/p1436) )。这篇论文是对 [p0796](https://wg21.link/p0796) 的继承，希望通过遗嘱执行人属性机制将亲缘关系作为遗嘱执行人的属性。
*   “停止标记和连接螺纹，版本 9”([p 0660](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0660r9.pdf))。这篇论文已经由 LEWG 转发，将在 C++20。在 LWG 审查之前，SG1 投票批准了一些措辞变更。

星期五对 SG1 来说是短暂的一天，我们考虑了几篇与纤维相关的论文:

*   "纤程 _ 上下文-没有调度程序的纤程"( [p0876](https://wg21.link/p0876) )。这份报纸已经流传了一段时间了。这篇论文的作者以及最近被批准的协程功能再次声明，接受协程并不意味着我们不需要纤程。大部分讨论围绕措辞审查，基于 Kona 讨论的更新措辞有望在 7 月的科隆会议上提出。
*   关于 SG1 议程上的纤维的另外两篇论文是“放大镜下的纤维”( [p1364](https://wg21.link/p1364) )和“对‘放大镜下的纤维’的回应”( [p0866](https://wg21.link/p0866) )。第一篇文章对纤程实现和无栈协同程序的性能和开销做了各种各样的声明，第二篇文章对此进行了反驳。

敬请关注更多报道。

*Last updated: June 20, 2019*