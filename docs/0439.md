# C 和 C++中别名的利与弊，第 2 部分

> 原文：<https://developers.redhat.com/blog/2020/06/03/the-joys-and-perils-of-aliasing-in-c-and-c-part-2>

在[上一篇文章](https://developers.redhat.com/blog/2020/06/02/the-joys-and-perils-of-c-and-c-aliasing-part-1/)中，我讨论了优化代码中 C 和 C++语言限制的好处。在后半部分，我将介绍各种编程语言豁免和编译器扩展，开发人员可以使用它们或多或少地安全避开别名限制。我还将讨论别名的常见陷阱，这些陷阱是由标准语言结构的扩展和误用造成的，并举例说明这些陷阱可能导致的常见问题。

## 规则的例外

我在第 1 部分中介绍的别名规则所施加的限制可能看起来相对宽松，但是许多用例没有例外是不可能的，尤其是在系统级代码中。C 和 C++语言只编写了其中的两个豁免；剩下的是流行编译器中的实现定义的扩展。因为实现定义的扩展的表现力和功能往往优先于安全性和检测错误的能力，所以它们的使用经常充满危险——至少与使用标准机制一样多，如果不是更多的话。在这一节中，我将介绍编程语言豁免和编译器扩展。我将解释别名规则的这些例外是如何被普遍滥用的，以及滥用它们的后果。

### 字符类型的别名

C 和 C++都提供了对第 1 部分中介绍的类型别名要求的豁免。这个豁免允许您通过调用像`memcpy`和`memmove`这样的函数或者它们的用户定义的等效函数来复制对象。这个豁免说明，除了它自己的类型之外，任何类型的对象都可以通过`unsigned char`的左值或任何其他窄字符类型访问它的值，尽管这个豁免最好限于`unsigned char`。(在最近的 C++中，也可以使用特殊的库类型`std::byte`。)

我们可以使用左值`unsigned char`来防止您在第 1 部分中看到的优化: *[通过指向不兼容类型](https://godbolt.org/z/Cmg5a3)* 的指针进行访问。在这里考虑修改后的版本(也参见通过字符类型 访问 *[):](https://godbolt.org/z/u4i__j)*

```
	int f (int *a, long *b)
	{
	    int t = *a;
  	    for (int i = 0; i != sizeof *b; ++i)
	        ((unsigned char*)b)[i] = 0;

	    return *a - t;   // must not be folded
	}
```

在这种情况下，编译器不能折叠`return`表达式，因为如果在`b`等于`a`的情况下调用该函数，它将是有效的。然而，在声明`a`和`b`指针时使用`restrict`会导致调用带有重叠对象的`f`无效。这样做将重新启用优化机会。

这种豁免使编译器不会对通过指向不兼容类型的指针访问对象的函数做出假设。即使在假设指针指向不同的对象是安全的上下文中也是如此，比如当指针指向不同的类型时。例如，考虑我们也可能在另一个函数中使用本例中的`for`循环。如果`f`调用另一个函数，编译器必须避免折叠`return`表达式，即使`*b`也是在`f`中读取的。

然而，`unsigned char`访问其他类型对象的权限并没有解除`restrict`关键字所施加的约束。使用带有指针`a`的`restrict`关键字意味着`a`和`b`要么不重叠，要么如果重叠，`g(b)`不会通过`*b`或任何其他方式修改`*a`。

下一个例子显示了至少一个编译器如何利用这个限制来折叠`return`表达式中的减法(参见限制限定符 的 *[传递性):](https://godbolt.org/z/mmo8uJ)*

```
	void g (void *);

	int f (int * restrict a, void * b)
	{
            int t = *a;
            g (b);           // can be assumed not to modify *a
            return *a - t;   // can be folded to zero
	}
```

不管`b`指向什么类型，或者`b`是否用`restrict`关键字声明，这种优化都是可能的。然而，请注意，为了清楚起见，最好为所有的指针参数声明`restrict`，您打算遵守这个限制。

### 公共初始序列

正如我前面提到的，通过类型的左值访问每个对象的要求也排除了使用指向另一个`struct`的指针访问一个`struct`的成员，即使两个成员具有相同的类型。然而，事实证明这种形式的别名在同一个联合的成员之间是有用的。为了支持这个用例，C 和 C++提供了特殊的豁免，当两个`struct`是同一个联合的成员时，访问它们共同的初始序列是有效的。程序员可以利用这个特殊的异常来修改原本不兼容的`struct`类型的初始成员，如下所示(见 *[通用初始序列](https://godbolt.org/z/qo3izJ)* ):

```
	struct A { int num, a[2]; };
	struct B { int cnt, a[4]; };

	union U { struct A a; struct B b; };

	int f (struct A *a, struct B *b)
	{
	    int t = a->num;
	    ((union U*)b)->b.cnt = 0;   // may change a->num
	    return a->num - t;          // cannot be folded
	}
```

在这种情况下，用指向同一个对象的两个参数调用`f`是有效的。相反，如果编译器正在编译一个函数调用，该函数将指向不同的`struct`的指针作为参数，那会怎样？在这种情况下，编译器必须假设调用可以修改`struct`成员的初始序列。

#### 实施说明

需要注意的一点是，公共初始序列由具有兼容类型的成员组成。对于数组，兼容类型包括它们的大小。序列以类型不完全兼容的一对成员的第一次出现结束。示例中的序列只包含两个成员`a->num`和`b->cnt`。然而，它没有扩展到`a->a`和`b->a`数组的前两个元素，尽管它们具有相同的类型。原因是数组的类型不兼容——`int[2]`与`int[4]`不兼容，甚至与`int[]`也不兼容。

另一件要注意的事情是，所有实现者并不一致地解释通用的初始序列规则。因此，不同的编译器可能在如何处理对联合初始成员的访问上存在分歧。在最保守的解释中，联合类型的简单定义意味着对共享一个公共初始序列的`struct`对象的任何访问都应该被认为是别名，除非被证明不是。另一方面，最严格的解释是访问必须涉及到对 union 类型的强制转换。示例中显示的后一种实现是可移植代码最安全的方法。GNU 编译器集合(GCC)使用这种解释。

### 通过联合的类型双关

*公共初始序列*豁免表示当两个`struct`是同一个联合的成员时，访问它们的公共初始序列是有效的。作为该规则的扩展，如果两种类型都是同一个联合的成员，那么通过另一种类型的左值来访问一种类型的对象也是可以接受的。这种访问——通过一个类型的左值而不是它的存储值来读取对象——被称为*类型双关*。这在标准 C 中是允许的，但在 C++中是不允许的。

GCC 支持两种语言中的类型双关，其限制性解释类似于它为通用初始序列提供的解释。在这种情况下，访问表达式必须包含联合类型。参见 GCC 手册中关于类型双关的[注释。](https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Optimize-Options.html#Type-punning)

### 属性`may_alias`

通过扩展对`unsigned char`的豁免，可以使用 GCC 的`[may_alias](https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Common-Type-Attributes.html#Common-Type-Attributes#index-may_005falias-type-attribute)`类型属性来定义一个不受基于类型的别名限制的类型。像`unsigned char`一样，我们可以使用用该属性声明的类型的左值来访问任何类型的对象(参见 *[通过`may_alias`类型](https://godbolt.org/z/y5-GZr)* 访问):

```
	int f (int *a, long *b)
	{
	    int t = *a;

	    typedef __attribute__ ((may_alias)) long AliasLong;
	    *(AliasLong*)b = 0;
	    return *a - t;
	}
```

以这种方式使用，`may_alias`通过指向不兼容类型的指针来防止在[访问的例子中发现的优化。在这个例子中，编译器不能折叠`return`表达式，因为现在`b`指向与`a`相同的对象是有效的。](https://godbolt.org/z/Cmg5a3)

## 别名和弱符号

为了支持低级程序和库，GCC 和兼容的编译器提供了几个扩展，使得为函数和变量定义别名成为可能。像`may_alias`一样，你会看到这些扩展通常采用属性的形式，或者有时采用 pragmas 的形式。

### 属性`alias`

当应用于函数或变量的声明时，属性`alias`告诉编译器，声明的符号为被命名的符号提供了一个*别名*，或者替代标识。被命名的符号被称为别名*目标*。目标必须在与别名相同的翻译单元中定义；别名本身只能声明，不能定义。通常，特别是在库中，别名被声明为普通符号，没有属性。这个声明放在一个程序可以包含的头文件中。目标通常不在公共头中声明。

别名最常用于为函数提供另一个名字，但它们也适用于变量。例如，因为在下面的例子中`b`被声明为别名——或者数组`a`的另一个名称——编译器不能再将`return`表达式折叠为零(参见变量 上的 *[属性别名):](https://godbolt.org/z/aB4Akp)*

```
	int a[8];
	extern __attribute__ ((alias ("a"))) int b[8];

	int f (int i, int j)
	{
	    int t = a[i];
	    b[j] = 0;          // modifies a
	    return a[i] - t;   // cannot be folded
	}
```

别名声明是一个定义，即使同时声明了`extern`。别名目标必须在与别名声明相同的翻译单元中定义。因此，在一般情况下，没有办法在头文件中声明一个别名来让编译器知道这两个别名指的是同一个符号。这个事实违反了 C 和 C++对象模型的一个基本原则，即不同的声明必须指定不同的实体。

如果编译器依赖于这一原则(正如它们都不可避免的那样)，使用`alias`属性会导致令人惊讶的结果。例如，别名和目标都在头文件中声明，并在程序中使用。编译器可能会在函数中将`return`语句中的减法折叠为零。这就像上面例子中的`f`，但是在不同的源文件中。

别名很有用，也很重要，但是如果不特别小心，使用它们可能会导致一些细微的错误。

### 属性`weak`

`[weak](https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Common-Function-Attributes.html#index-weak-function-attribute)`属性类似于`alias`属性:它声明它所附加的函数或变量表示一个 *[弱符号](https://en.wikipedia.org/wiki/Weak_symbol)* ，它可以(但不需要)在程序的其他地方定义。如果符号没有被定义，它的地址等于空。和`alias`一样，`weak`属性也主要是为了提供一种声明“特殊”库函数的机制。

典型的例子是`malloc`系列函数，它是 C 库的基于 Unix 的实现，允许程序用自己的替代函数来替换。在这种情况下，将使用“强”定义来代替弱定义。在变量声明中指定`weak`属性与在函数中指定属性具有相同的含义。然而，与`alias`不同，弱符号不需要定义。在这些情况下，这种未定义的弱符号(函数或变量)的地址为空，因此在使用这种符号之前，必须测试其地址是否为非空。

这条规则与 C 和 C++标准相冲突，C 和 c++标准要求程序中每个函数和对象的地址必须是非空的。然而，只要被测试的声明是一个弱符号(意思是，它有属性`weak`)，编译器就不会使用标准要求来删除这样的测试。

你可以在下面的函数中看到一个例子，其中`a`没有被声明为弱符号，因此被认为声明了一个普通或强符号。`a`的测试被删除，但`b`的测试被保留(参见 *[测试符号地址是否等于空值](https://godbolt.org/z/UFqHFJ)* ):

```
	extern int a[8];
	extern __attribute__ ((weak)) int b[8];

	int f (int i, int j)
	{
	    int t = a ? a[i] : 0;     // replaced by 'int t = a[i];'
	    if (b)                    // test emitted
	        b[j] = 0;             // may modify a
	    return a ? a[i] - t : 0;  // folded to zero
	}
```

#### 弱声明

任何符号都可以声明为`weak`。如果我们在不同的文件中声明`a`是`weak`，再次删除测试将会导致令人惊讶的结果。因此，如果一个声明声明一个符号是弱的，它们都应该声明。编译器倾向于一次翻译一个源文件，所以对不这样做的代码发出警告是不可行的。

此外，因为外部符号也可以被声明为别名，所以如果在另一个源文件中将`b`声明为`a`的别名，结果将会令人惊讶，并且很可能是不正确的。为了说明风险，假设我们编译了上面的文件，并将其链接到一个完整的程序，该程序的文件包含以下声明:

```
	#include <stdio.h>

	int b[8] = { 0, 1 };
	extern __attribute__ ((alias ("b"))) int a[8];

	int f (int, int);

	int main (void)
	{
	    int n = f (1, 1);
	    printf ("%i %i\n", b[1], n);
	}
```

尽管完整的程序编译和链接时没有警告，但当我们运行它时，它的行为就好像`a`和`b`是不同的对象，即使它们是同一个对象。

## 零长度数组

与到目前为止讨论的扩展相反，GCC 的[零长度数组](https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Zero-Length.html)特性并不意味着提供一个别名规则的出口。相反，它是一种古老的机制，旨在解决缺少灵活数组成员的问题，灵活数组成员是在 C99 中首次引入的。零长度数组和灵活数组成员的目标都是声明一个大小在运行时确定的结构。它允许这种结构的最后一个成员是一个数组，该数组包含不确定数量的零个或多个元素。但是，与必须始终是结构对象的最后一个成员的灵活数组成员不同，零长度数组在任何上下文中都是可以接受的——即使是作为其他成员跟随的内部结构成员。

除了填充之外，对内部零长度数组的元素的访问实际上是对后续成员的访问。这不是预期的特性，而是过度宽松设计的结果。编译器可以(GCC 也这样做)假设这种重叠访问不会发生。结果，GCC 10 使用新的`[-Wzero-length-bounds](https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Warning-Options.html#index-Wzero-length-bounds)`警告来诊断对内部零长度数组的访问。

下一个例子说明了无效的假设，即数组访问可能别名相同对象的其他成员，以及检测到它的警告(另见 *[别名由零长度数组](https://godbolt.org/z/xWDRH7)* ):

```
	struct A { int n, a[0]; };
	struct B { struct A a; int x; };

	int f (struct B *p, int i)
	{
	    int t = p->x;
	    p->a.a[i] = 0;     // -Wzero-length-bounds
	    return p->x - t;   // can be folded to zero
	}
```

## 退出别名规则

正如迄今为止的例子所显示的，C 和 C++概述了关于程序中符号和对象的身份的确切要求。遵守这些要求的程序通过减少重新加载未更改值所需的内存访问次数而受益。但是那些没有考虑到这些需求的程序呢？遗留软件和糟糕的代码都忽略了别名需求，尽管原因不同。这些程序是否有办法退出别名规则？

虽然您可能认为答案是肯定的，但事实证明，在大多数情况下，答案是否定的。GCC 和兼容的编译器确实提供了`[-fno-strict-aliasing](https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Optimize-Options.html#index-fstrict-aliasing)`选项，但它仅适用于规则的子集；即基于类型的别名。`-fno-strict-aliasing`选项不会阻止 GCC 做出我已经讨论过的其他假设，包括那些关于对象的身份和没有其他形式的别名(比如零长度数组)的假设。

## 别名豁免的代价

与大多数规则的例外情况一样，允许其他类型访问任何类型的对象是有代价的。C++ `std::string`容器的一个特殊用法很好地说明了这个问题。鉴于`std::string`只不过是一个字符指针的包装器——特别是`const char*`——编译器假设对`std::string`对象的任何修改都有可能修改程序中该指针可以到达的任何对象。唯一的例外是，如果编译器可以跟踪包装指针的值(或者，用一个更专业的说法，*跟踪其出处*)并证明不是这样。即使类保证包装的指针除了由对象管理的内部缓冲区之外从不指向任何东西，这条规则也成立。

您可以在下一个示例中看到这个缺陷，我们希望编译器将`return`表达式折叠为零。由于豁免，没有编译器能够做到这一点(也见 *[访问由 std::string 别名任何东西](https://godbolt.org/z/bGqEzd)* ):

```
	#include <string>

	int x;

	int f (std::string &str)
	{
	    int t = x;
	    str = "";       // assumed to alias x
	    return t - x;   // not folded to zero
	}
```

在这种情况下，代价是效率损失，而且问题不仅限于`std::string`。它影响任何嵌入了用于访问数据的内部指针的 C 或 C++容器类型。对于指向其他类型的指针，比如`int*`，问题的范围仅限于兼容类型的对象。因此，在这个例子中，我们必须假设`std::vector<int>`修改了任何类型为`int`的可到达变量。

除了效率的损失之外，免除原本严格的规则还有另一个后果:它们限制了检测和诊断编码错误的能力。例如，通过接受零长度数组的声明，即使它们后面跟有另一个成员，编译器也可能会将错误引入到任何访问这些成员的代码中(参见 *[通过零长度数组访问](https://godbolt.org/z/5iHLRf)* ):

```
	struct A { int x, a[0], y; };

	int f (struct A *a)
	{
	    int t = a->y;
	    a->a[0] = 123;     // overlaps with a->y
	    return t - a->y;   // folded to zero
	}
```

除了不支持扩展的 Visual C++，所有测试的编译器都将本例中的`return`表达式折叠为零。然而，当用一个对象的地址调用时，该对象的成员`y`被设置为除了`123`之外的任何值，该函数返回一个意外的结果:也是零。GCC 10 是唯一检测到这种可能的错误的编译器；它通过发出`[-Wzero-length-bounds](https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Warning-Options.html#index-Wzero-length-bounds)`警告来做到这一点。不幸的是，当零长度数组是一个`struct`子对象的最后一个成员时，GCC 10 对同样的错误无能为力，这个子对象后面是另一个`struct`子对象的另一个成员。

这不是标准灵活数组成员的问题。C 语言要求在最外层的封闭结构中最后定义。这也意味着具有灵活数组成员的结构不能用于声明另一个结构的成员。遗憾的是，GCC 接受这种无效使用作为另一种扩展，有可能导致同样的 bug(参见 *[灵活数组成员](https://godbolt.org/z/V_Z849)* 别名访问):

```
	struct A { int x, a[]; };
	struct B { struct A a; int y; };

	int f (struct A *a, struct B *b)
	{
	    int t = b->y;
	    a->a[1] = 123;     // overlaps with b->y
	    return t - b->y;   // folded to zero
	}
```

### 检测别名错误的警告

本文测试的流行编译器都没有检测到我们讨论过的任何别名错误。然而，GCC 和兼容的编译器暴露了两个警告选项，它们被设计来检测这些 bug 的不相交子集:`[-Wstrict-aliasing](https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Warning-Options.html#index-Wstrict-aliasing)`和`[-Wrestrict](https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Warning-Options.html#index-Wrestrict)`。`-Wstrict-aliasing`是一个多级选项，旨在检测基于类型的别名规则的基本违规。另一方面，`-Wrestrict`通过 GCC 已知的字符串操作函数子集中的`restrict`限定的指针检测重叠访问，并将相同的指针传递给用户定义函数中的`restrict`限定的参数。

此外，GCC 10 包括新的`[-Wzero-length-bounds](https://gcc.gnu.org/onlinedocs/gcc-10.1.0/gcc/Warning-Options.html#index-Wzero-length-bounds)`警告，用于检测对零长度数组的访问。

这三个警告都包含在 GCC 的`-Wall`中。虽然当前的实现仍有很大的改进空间，但它们标志着编译器实现者正朝着正确的方向前进，并试图检测这些否则难以捕捉的错误。

## 结论

在这个由两部分组成的系列文章中，您了解了在 C 和 C++中仔细遵循别名规则可以提高运行时效率。与此同时，绕过规则是很容易的，无论是出于需要还是出于错误。正如许多例子所强调的，这些例外通常伴随着相当大的风险。不正确或不小心使用它们会导致难以发现的错误。

使用豁免意味着编译器只能依赖规则，如果它能证明没有使用豁免的话。否则，编译器必须保守地假设这些规则已经被绕过。鉴于编译器对程序的可见性有限，这种保守的假设通常会导致次优的性能。当我们考虑到大多数代码*遵循规则，只有一小部分使用豁免时，这是非常不幸的。*

历史上，C 和 C++编译器是以信任程序员的理念开发的。因此，很少有资源专门用于验证代码是否符合我们优化的基本假设。由于广泛宣传的错误，这种情况开始发生变化。尽管如此，编译器在优化之前只是缓慢地添加检查，以验证代码是有效的，并且没有豁免被滥用。这种检查的效力也往往相当有限。几乎没有人能看到整个程序，因此他们一次最多只能分析一个源文件。

为了最大化别名规则的好处，并最小化落入我在本系列中概述的许多陷阱的风险，我建议编写严格遵循规则的代码，并避免依赖豁免和扩展，除非是必要的。另外，我建议使用`-Wall`、`-Wextra`或等效的编译器选项来启用警告并解决它们的所有实例。

请记住，编译器在每个版本中发现问题的能力都在提高。尽可能早地升级到最新的编译器版本。最后，如果您发现一个您认为您的编译器应该能够检测到的 bug，向 GCC [Bugzilla](https://gcc.gnu.org/bugzilla/) 提交一个测试用例(第一次提交者应该阅读[如何报告 bug 或增强请求](https://gcc.gnu.org/bugs/)，并要求编译器的实现者对其进行诊断)。随着对未定义行为的后果越来越敏感，很可能有人会努力确保在编译器的未来版本中可以检测到这个 bug。

*Last updated: June 25, 2020*