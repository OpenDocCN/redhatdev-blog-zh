# GNU C 库如何处理向后兼容性

> 原文：<https://developers.redhat.com/blog/2019/08/01/how-the-gnu-c-library-handles-backward-compatibility>

GNU C 库(glibc)的一条不成文的规则是，基于旧版本的 glibc 构建的程序将继续支持新版本的 glibc。但是这是如何工作的呢？是什么隐藏的魔力让你调用同一个函数却得到不同的结果，仅仅是基于你构建程序的时间？

## 添加魔法符号

这种魔力被称为“compat symbols”，它让 glibc 和静态链接器(构建时使用的那个)从函数的许多实现中选择一个。例如，如果我们查看 32 位`libc-2.29.so`的动态符号表，我们会看到三个版本的`glob64`函数(在 2017 年，`glob`函数被更改为以不同的方式处理悬空符号链接，这将导致旧程序崩溃，但这是一个不同的故事):

```
$ readelf --dyn-syms -W /lib/libc-2.29.so | grep glob64
   411: 0012d0e0  7183 FUNC    GLOBAL DEFAULT   14 glob64@GLIBC_2.1
   412: 0012edb0  7183 FUNC    GLOBAL DEFAULT   14 glob64@GLIBC_2.2
   413: 000b69a0  7183 FUNC    GLOBAL DEFAULT   14 glob64@@GLIBC_2.27

```

在你的程序中，你只引用`glob64()`。动态链接器(启动程序时调用的链接器)搜索以`glob64`开头，后跟`@@`和其他符号的符号。`@@`告诉动态链接器这个版本是默认版本。在这种情况下，动态链接器会找到`glob64@@GLIBC_2.27`，因为应用程序二进制接口(ABI)最后一次更改是在 glibc 2.27 中。链接器用`@`替换`@@`生成`glob64@GLIBC_2.27`，存储在程序的动态符号表中。

如果动态链接器没有找到任何`@@`符号，它会像往常一样寻找一个未版本化的符号。

接下来，当你的程序*运行*动态链接器并看到所有符号上的版本号时，它链接到相应的版本号，因为名称现在匹配了。这里唯一的例外是每个符号的当前版本在共享对象中仍然有`@@`，它与程序中的`@`相匹配:

```
$ readelf --dyn-syms -W myprog.x | grep glob64
     2: 00000000     0 FUNC    GLOBAL DEFAULT  UND glob64@GLIBC_2.27 (2)

```

现在考虑这样一种情况，我们已经针对 C 库的 2.26 版本构建了一个程序。在这种情况下，当您链接 glibc 的动态符号表时，它会显示如下内容:

```
   411: 0012d0e0  7183 FUNC    GLOBAL DEFAULT   14 glob64@GLIBC_2.1
   412: 0012edb0  7183 FUNC    GLOBAL DEFAULT   14 glob64@@GLIBC_2.2

```

你的程序会选择 GLIBC 2.2 版本作为“最新”的符号，并在其动态符号表中添加`glob64@GLIBC_2.2`。

如果您在装有 glibc 2.27 的系统上运行该构建，动态链接器会看到您已经针对该符号的 2.2 版本进行了构建，并将您链接到 2.2 版本*，尽管有更新的版本可用。*

## 更换兼容的 ABI

假设你想在你自己的图书馆里做类似的事情。考虑以下示例代码:

```
int lookup (int index)
{
 . . .
}

```

几次释放之后，您意识到您想要传递一个指向您想要查找的内容的指针:

```
int lookup (int index, void *data)
{
 . . .
}

```

你的库中不能有两个相同功能的副本。你不想改变函数的名字，所以你写了这样的东西:

```
__asm__(".symver lookup_v2, lookup@@v2");
int lookup_v2 (int index, void *data)
{
 . . .
}

__asm__(".symver lookup_v1, lookup@");
int lookup_v1 (int index)
{
 . . .
}

```

我们现在有两个不同命名的函数。原始代码现在是`lookup_v1`，并被设置为版本`@`，这意味着“没有版本标签，但不是默认版本。”动态符号表对此符号有一个条目`lookup`，这是您的旧二进制文件所期望的。

新功能`lookup_v2`被设置为版本`@@v2`，其中`@@`意味着它是任何新链接程序的默认。如果你链接一个程序到新的库，一个条目`lookup@v2`(注意*一个* `@`)被添加到它的动态符号表中。

这里的最后一步是告诉静态链接器你正在使用什么版本，隐藏什么内部名字，使用一个类似这样的版本文件，我们称之为`mylib.vers`:

```
v1 {
  local: lookup_v1;
};

v2 {
  local: lookup_v2;
};

```

您使用`--version-script`选项将这个版本文件指定给静态链接器，如下所示:

```
  gcc . . . -Wl,--version-script,mylib.vers

```

注意与我们正在使用的版本相对应的`v1`和`v2`子句。我们还使用`local`命令来“隐藏”实现旧版本的函数的内部名称。这种做法使得(例如)`lookup_v2`符号在库的范围内是局部的，在库之外是不可见的。

## 提前计划

对于 glibc，从一开始就使用了版本控制。如果您将通配符版本添加到您的版本脚本中，也可以这样做，如下所示:

```
v1 {
  *;
};

```

这段代码将没有特定版本的*所有*符号的版本设置为`v1`。当然，您只希望在首次发布之前这样做，因为对符号进行版本控制本身就是一项 ABI 变更。然后，在开发库的未来版本时，添加更多版本子句，并在这些新子句中列出新符号。

## 了解兼容性的限制

尽管兼容性有着悠久的历史，而且它有着让旧程序保持运行的近乎神奇的能力，但有一个场景是兼容性无法解决的。你不能在旧的 glibc 上运行新程序。嗯，不完全是这样。如果你有一个旧 glibc 的副本和它的头文件，你可以构建一个新的程序在旧的 glibc 上运行。最简单的方法是安装一个旧的操作系统，安装你想要的 glibc 版本，这是“在你想要支持的最老的平台上构建”的典型建议，可能使用一个更现代的工具集(gcc 等)，如 [Red Hat 的开发者工具集](https://developers.redhat.com/products/developertoolset/overview)，它就是为此而创建的。这样，新程序只依赖于在旧的 glibc *和任何更新的 glibc* 中可用的兼容性符号。当然，年长的 glibcs 无法预知未来。

除非你能预测未来，在这种情况下，请已经与我联系。

## 了解你的缺点、选择和注意事项

由于这是一篇短文，许多细节被忽略了。例如，`@@`语法仅仅是可执行和可链接格式(ELF)结构内部的用户可见版本，这超出了本文的范围。

虽然您的程序可以链接到两个使用同一符号的两个不同版本的动态共享对象(DSO )(也就是说，这两个 DSO 是针对不同的 glibc 版本构建的),但是不支持这种情况。glibc 开发人员尽最大努力让它工作，但是如果它坏了，你可以保留两个部分。

类似地，使用`dlsym`在 glibc(或任何其他版本化的 DSO)中查找符号会导致使用与您使用的其他 DSO 不同的符号版本，但有相同的注意事项。

## 了解更多信息

以下是您可能感兴趣的其他材料:

*   [ld 的版本命令](https://sourceware.org/binutils/docs-2.32/ld/VERSION.html)
*   [glibc wiki:符号版本化](https://sourceware.org/glibc/wiki/SymbolVersioning)
*   [“如何编写共享库”](https://akkadia.org/drepper/dsohowto.pdf)作者 Ulrich Drepper，2011 年 12 月

*Last updated: July 29, 2019*